<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Proyecto Armando</title>

<style>

  body {
    font-family: 'Segoe UI', sans-serif;
    background: #dbdace;
    color: #a1a1a1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }

  h1 { margin-bottom: 10px; color: #1a1a1a; }

  .controls { margin-bottom: 20px; }

  button {
    background: #3b5dd1;
    border: none;
    color: #f1f1f1;
    padding: 8px 14px;
    margin: 4px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover { background: #5a7be0; }

  #timers-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    width: 90%;
    max-width: 900px;
  }

  .timer {
    background: #1a2f7a;
    border: 1px solid #333;
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .timer.completed {
    background: #164d16;
    border-color: #1d7a1d;
  }

  .timer p span {
    font-size: 2rem;
    font-weight: bold;
    color: #fff;
  }

  .timer h3 { margin: 5px 0; }
  .timer p { margin: 2px 0; }

  .timer .buttons {
    display: flex;
    gap: 6px;
  }

  .draggable { cursor: move; }

  .input-group {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 8px;
  }

  input, textarea {
    padding: 6px;
    border-radius: 5px;
    border: 1px solid #555;
    background: #181818;
    color: #eee;
  }

  textarea { resize: vertical; }

  .hidden { display: none !important; }

  #userSection { margin-bottom: 20px; text-align: center; }

  #loginPanel {
    background: #1c1c1c;
    padding: 20px;
    border-radius: 10px;
    border: 1px solid #333;
    text-align: center;
  }

  #loginPanel input {
    width: 200px;
    margin: 5px 0;
  }

  /* ‚úÖ CAMBIO 1: men√∫ alineado a la derecha */
  #menu {
    position: fixed;
    top: 10px;
    right: 10px;
    left: auto;
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  #dayInfo {
    margin-bottom: 20px;
    text-align: center;
  }

  /* Estilos tabla de registro */
  #registroTable {
    width: 95%;
    max-width: 1100px;
    border-collapse: collapse;
    margin-top: 12px;
    background: #f7f7f7;
    color: #111;
    border-radius: 8px;
    overflow: hidden;
  }
  #registroTable thead th {
    background: #3b5dd1;
    color: #fff;
    padding: 10px;
    text-align: left;
    font-weight: 600;
  }
  #registroTable tbody td {
    padding: 8px 10px;
    border-bottom: 1px solid #e0e0e0;
    font-size: 0.95rem;
  }
  .small { font-size: 0.9rem; color:#666; }
  #registroControls { margin: 10px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  #registroWrapper { width: 100%; display:flex; flex-direction:column; align-items:center; }

  /* Una fila resaltada para eventos "sin d√≠a" */
  .no-day { background: #fff3cd !important; }

</style>
</head>

<body>

<h1>Proyecto Armando</h1>

<!-- üîµ MENU SUPERIOR -->
<div id="menu">
  <button onclick="openSection('mainPage')">üè† Cron√≥metros</button>
  <button onclick="openSection('statsGeneral')">üìä Estad√≠sticas Generales</button>
  <button onclick="openSection('statsPersonal')">üë§ Estad√≠sticas Individuales</button>
  <button onclick="openSection('registroEventos')">üìú Registro de eventos</button>
</div>


<!-- üîµ SECCI√ìN PRINCIPAL -->
<section id="mainPage">

  <div id="dayInfo" class="hidden"></div>

  <!-- LOGIN -->
  <div id="loginPanel">
    <h3>Acceso privado</h3>
    <input type="email" id="emailInput" placeholder="Correo autorizado">
    <input type="password" id="passwordInput" placeholder="Contrase√±a">
    <button id="loginEmailBtn">Ingresar</button>
    <p id="loginError" style="color:#ff5555;"></p>
  </div>

  <!-- Info de usuario -->
  <div id="userSection" class="hidden">
    <p id="userInfo"></p>
    <button id="logoutBtn">Cerrar sesi√≥n</button>
  </div>

  <div class="controls hidden" id="mainControls">
    <button id="startDayBtn">üåÖ Iniciar D√≠a</button>
    <button id="endDayBtn">üåá Finalizar D√≠a</button>
    <button id="addTimerBtn">‚ûï Nuevo Cron√≥metro</button>
  </div>

  <div id="formSection" class="hidden">
    <div class="input-group">
      <input type="text" id="activityName" placeholder="Nombre de la actividad">
      <input type="number" id="targetMinutes" placeholder="Minutos objetivo" min="1">
    </div>

    <div class="input-group">
      <textarea id="note" placeholder="Nota (opcional)"></textarea>
    </div>

    <button id="createTimerBtn">Crear</button>
  </div>

  <div id="timers-container"></div>

</section>


<!-- üîµ ESTAD√çSTICAS GENERALES -->
<section id="statsGeneral" class="hidden">
  <h2>üìä Estad√≠sticas Generales</h2>
  <div id="statsGeneralEmbed"></div>
</section>

<!-- üîµ ESTAD√çSTICAS INDIVIDUALES -->
<section id="statsPersonal" class="hidden">
  <h2>üë§ Estad√≠sticas Individuales</h2>
  <div id="statsPersonalEmbed"></div>
</section>

<!-- üîµ REGISTRO DE EVENTOS -->
<section id="registroEventos" class="hidden">
  <h2>üìú Registro de eventos (historial)</h2>

  <div id="registroWrapper">
    <div id="registroControls">
      <span class="small">Se muestran eventos sincronizados desde Firebase y asignados a d√≠as de trabajo calculados a partir de <b>dia_iniciado</b> / <b>dia_finalizado</b>.</span>
      <button id="refreshRegistroBtn">üîÅ Refrescar ahora</button>
    </div>

    <table id="registroTable">
      <thead>
        <tr>
          <th>D√≠a</th>
          <th>Cron√≥metro</th>
          <th>Acci√≥n</th>
          <th>Marca</th>
          <th>Fecha y hora</th>
          <th>Objetivo (min)</th>
          <th>Creado</th>
        </tr>
      </thead>
      <tbody id="registroBody">
        <!-- filas generadas din√°micamente -->
      </tbody>
    </table>
  </div>
</section>

<!-- üîµ SCRIPT -->
<script type="module">

/* --- FIREBASE (modular v11) --- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getDatabase,
  ref,
  set,
  update,
  onValue,
  push,
  get,
  child,
  serverTimestamp
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
import {
  getAuth,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyCby9oxzPzBDllkzuW21ZoGNJh67UgYZ8E",
  authDomain: "notion-timers-2a3bb.firebaseapp.com",
  databaseURL: "https://notion-timers-2a3bb-default-rtdb.firebaseio.com",
  projectId: "notion-timers-2a3bb",
  storageBucket: "notion-timers-2a3bb.firebasestorage.app",
  messagingSenderId: "78500747038",
  appId: "1:78500747038:web:2b5fdec3731a203c7f1b0f"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);


/* -------- ESTADO GLOBAL -------- */
let dbRef = null;
let currentUid = null;
let timers = {};        // timers como objeto: id -> timer
let timersOrder = [];   // array con ids en orden visual
let dayStarted = null;
let dayEnded = null;
let eventosRefGlobal = null;
let lastEventosListener = null;


/* -------- LOGIN -------- */

document.getElementById("loginEmailBtn").onclick = async () => {
  const email = document.getElementById("emailInput").value;
  const pass = document.getElementById("passwordInput").value;

  try {
    await signInWithEmailAndPassword(auth, email, pass);
  } catch(e){
    document.getElementById("loginError").textContent="Credenciales incorrectas";
    console.error(e);
  }
};

document.getElementById("logoutBtn").onclick = () => signOut(auth);


/* -------- AUTH LISTENER / DB REF -------- */

onAuthStateChanged(auth, user => {
  if(user){
    currentUid = user.uid;

    document.getElementById("loginPanel").classList.add("hidden");
    document.getElementById("userSection").classList.remove("hidden");
    document.getElementById("mainControls").classList.remove("hidden");

    document.getElementById("userInfo").textContent = `Conectado como: ${user.email}`;

    dbRef = ref(db, `usuarios/${user.uid}/cronometros`);
    listen();

    eventosRefGlobal = ref(db, `usuarios/${user.uid}/historialEventos`);

  } else {

    currentUid = null;
    dbRef = null;

    document.getElementById("loginPanel").classList.remove("hidden");
    document.getElementById("userSection").classList.add("hidden");
    document.getElementById("mainControls").classList.add("hidden");

    timers = {};
    timersOrder = [];
    renderTimers();
  }
});


/* -------- LISTENER PRINCIPAL -------- */
function listen() {
  onValue(dbRef, snap => {
    const data = snap.val() || {};
    // dayStarted/dayEnded ser√°n n√∫meros (ms) si vienen de serverTimestamp
    dayStarted = data.dayStarted || null;
    dayEnded = data.dayEnded || null;
    timers = data.timers || {}; // objeto de timers
    timersOrder = Array.isArray(data.timersOrder) ? data.timersOrder : Object.keys(timers).sort((a,b) => (timers[a]?.createdAt||0) - (timers[b]?.createdAt||0));
    // Exponer snapshot para estadisticas
    window.currentTimersSnapshot = timers;
    window.timersOrder = timersOrder;
    window.computeElapsedSec = computeElapsedSec;
    // limpiar completions por sesi√≥n si quieres (opcional)
    renderTimers();
  });
}


/* -------- UTILIDADES -------- */
function formatTimeFromSeconds(s){
  if(s == null || s === undefined) return "";
  s = Number(s);
  if(isNaN(s)) return "";
  const h = String(Math.floor(s/3600)).padStart(2,"0");
  const m = String(Math.floor((s%3600)/60)).padStart(2,"0");
  const s2 = String(s%60).padStart(2,"0");
  return `${h}:${m}:${s2}`;
}

function formatLocal(ts){
  try {
    if(!ts) return "";
    // ts puede ser n√∫mero (ms) o ISO
    const d = (typeof ts === "number") ? new Date(ts) : new Date(ts);
    return d.toLocaleString();
  } catch(e){
    return ts;
  }
}

function escapeHtml(unsafe) {
  if(!unsafe && unsafe !== 0) return "";
  return String(unsafe)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'", "&#039;");
}


/* -------- C√ÅLCULO DE ELAPSED FIABLE --------
   - saved elapsed (segundos)
   - startedAtServer (ms timestamp) si est√° corriendo
*/
function computeElapsedSec(timer){
  const saved = Number(timer.elapsed || 0);
  if(!timer.running) return saved;

  const startedMs = timer.startedAtServer || null; // n√∫mero ms
  if(!startedMs) return saved;

  const now = Date.now();
  const delta = Math.floor((now - startedMs) / 1000);
  return saved + Math.max(0, delta);
}


/* -------- SAVE HELPERS -------- */

async function saveTimer(timerId, timerObj){
  if(!currentUid) return;
  const p = ref(db, `usuarios/${currentUid}/cronometros/timers/${timerId}`);
  try {
    await set(p, timerObj);
  } catch(e){
    console.error("Error guardando timer", e);
  }
}

async function removeTimerFromDb(timerId){
  if(!currentUid) return;
  const p = ref(db, `usuarios/${currentUid}/cronometros/timers/${timerId}`);
  try {
    await set(p, null);
  } catch(e){
    console.error("Error borrando timer", e);
  }
}

async function saveTimersOrder(){
  if(!currentUid) return;
  try {
    await update(ref(db, `usuarios/${currentUid}/cronometros`), {
      timersOrder,
      updatedAt: serverTimestamp()
    });
  } catch(e){
    console.error("Error guardando timersOrder", e);
  }
}

async function saveDay(){
  if(!currentUid) return;
  try {
    await update(ref(db, `usuarios/${currentUid}/cronometros`), {
      dayStarted,
      dayEnded,
      updatedAt: serverTimestamp()
    });
  } catch(e){
    console.error("Error guardando day", e);
  }
}

/* -------- LOG EVENTOS -------- */
async function logEvento(uid, tipo, dataExtra = {}) {
  if(!uid) return;
  try {
    const eventosRef = ref(db, `usuarios/${uid}/historialEventos`);
    const evento = {
      timestamp: serverTimestamp(),
      tipo,
      usuario: uid,
      ...dataExtra
    };
    await push(eventosRef, evento);
  } catch (e) {
    console.error("Error logeando evento:", e, tipo, dataExtra);
  }
}


/* -------- NAV SECTIONS -------- */
window.openSection = function(sectionId){
  document.getElementById("mainPage").classList.add("hidden");
  document.getElementById("statsGeneral").classList.add("hidden");
  document.getElementById("statsPersonal").classList.add("hidden");
  document.getElementById("registroEventos").classList.add("hidden");

  document.getElementById(sectionId).classList.remove("hidden");

  if(sectionId === "statsGeneral"){
    import("./estadisticas.js").then(mod => mod.renderStatsGeneral());
  } else if(sectionId === "registroEventos"){
    renderRegistroEventos();
  }
};


/* -------- CREAR CRON√ìMETRO -------- */
document.getElementById("createTimerBtn").onclick = async () => {
  const n = document.getElementById("activityName").value.trim();
  const t = Number(document.getElementById("targetMinutes").value);
  const note = document.getElementById("note").value.trim();

  if(!n || !t) return alert("Nombre y minutos requeridos.");

  const createdAt = Date.now();          // id √∫nico y estable (ms)
  const timerId = String(createdAt);

  const newTimer = {
    name: n,
    target: t,
    note,
    elapsed: 0,               // segundos
    running: false,
    completed: false,
    createdAt,                // ms
    startedAtServer: null     // ms (cuando se inicia se pone serverTimestamp())
  };

  // actualizar local y db
  timers[timerId] = newTimer;
  // push al order
  timersOrder.push(timerId);

  await saveTimer(timerId, newTimer);
  await saveTimersOrder();

  // log
  await logEvento(currentUid, "timer_creado", {
    timerId,
    name: n,
    target: t,
    note
  });

  // limpiar form
  document.getElementById("activityName").value="";
  document.getElementById("targetMinutes").value="";
  document.getElementById("note").value="";
  document.getElementById("formSection").classList.add("hidden");

  renderTimers();
};


/* -------- RENDER TIMERS -------- */
function renderTimers(){
  const container = document.getElementById("timers-container");
  container.innerHTML = "";

  // ids en el orden deseado: primero los de timersOrder (filtrando que existan), luego cualquier timer suelto
  const orderedFromOrder = timersOrder.filter(id => id in timers);
  const rest = Object.keys(timers).filter(id => !orderedFromOrder.includes(id)).sort((a,b) => (timers[a]?.createdAt||0) - (timers[b]?.createdAt||0));
  const ids = [...orderedFromOrder, ...rest];

  // Exponer snapshot para estadisticas
  window.currentTimersSnapshot = timers;
  window.timersOrder = timersOrder;

  // calcular totales para dayInfo usando TODOS los timers
  const totalTargetSeconds = Object.values(timers).reduce((sum, t) => sum + ((Number(t.target)||0) * 60), 0);
  const totalElapsedSeconds = Object.values(timers).reduce((sum, t) => sum + computeElapsedSec(t), 0);

  const dayInfoDiv = document.getElementById("dayInfo");
  if (dayStarted) {
    const start = new Date(dayStarted);
    const estimatedEnd = new Date(start.getTime() + totalTargetSeconds * 1000);
    const progress = totalTargetSeconds ? (totalElapsedSeconds / totalTargetSeconds * 100) : 0;

    dayInfoDiv.innerHTML = `
      <p>D√≠a iniciado: ${start.toLocaleString()}</p>
      <p>Hora estimada de fin: ${estimatedEnd.toLocaleString()}</p>
      <p>Progreso total: ${progress.toFixed(1)}%</p>
    `;
    dayInfoDiv.classList.remove("hidden");
  } else {
    dayInfoDiv.classList.add("hidden");
  }

  ids.forEach(id => {
    const t = timers[id];
    const displayElapsed = computeElapsedSec(t);
    const pctObj = t.target ? ((displayElapsed / (t.target * 60)) * 100).toFixed(1) : "0.0";
    const pctTotal = totalTargetSeconds ? ((displayElapsed / totalTargetSeconds) * 100).toFixed(1) : "0.0";

    const div = document.createElement("div");
    div.className = "timer" + (t.completed ? " completed" : "");
    div.dataset.timerId = id;
    div.draggable = true;

    div.innerHTML = `
      <h3>${escapeHtml(t.name || "")}</h3>
      <p><span>${formatTimeFromSeconds(displayElapsed)}</span></p>
      <p>Objetivo: ${t.target} min</p>
      <p>Progreso espec√≠fico: ${pctObj}%</p>
      <p>Progreso general: ${pctTotal}%</p>
      <p>Creado: ${formatLocal(t.createdAt)}</p>
      ${t.note ? `<p><i>${escapeHtml(t.note)}</i></p>` : ""}
      <div class="buttons">
        <button onclick="toggleTimer('${id}')">${t.running ? "‚è∏Ô∏è Pausa" : "‚ñ∂Ô∏è Iniciar"}</button>
        <button onclick="resetTimer('${id}')">üîÑ Reset</button>
        <button onclick="deleteTimer('${id}')">üóëÔ∏è Borrar</button>
        <button onclick="editTimer('${id}')">‚úèÔ∏è Editar</button>
      </div>
    `;

    container.appendChild(div);
  });

  // habilitar drag & drop tras renderizar
  enableDragAndDrop();
}


/* -------- TOGGLE (INICIAR / PAUSAR) -------- */
window.toggleTimer = async id => {
  if(!timers[id]) return;
  const t = timers[id];

  if(!dayStarted) return alert("Primero inicia el d√≠a.");

  if(!t.running){
    // iniciar: escribir startedAtServer con serverTimestamp
    t.running = true;
    // opcional: poner valor local inmediato para evitar flicker
    t.startedAtServer = Date.now();

    // Guardar solo ese timer con startedAtServer = serverTimestamp()
    try {
      await set(ref(db, `usuarios/${currentUid}/cronometros/timers/${id}`), {
        ...t,
        startedAtServer: serverTimestamp()
      });
    } catch(e){
      console.error("Error iniciando timer:", e);
    }

    await logEvento(currentUid, "timer_iniciado", {
      timerId: id,
      name: t.name,
      elapsedAntes: t.elapsed
    });

  } else {
    // pausar: calcular elapsed real y guardar
    const realElapsed = computeElapsedSec(t);

    t.running = false;
    t.elapsed = realElapsed;
    t.startedAtServer = null;

    await saveTimer(id, t);

    await logEvento(currentUid, "timer_pausado", {
      timerId: id,
      name: t.name,
      elapsed: t.elapsed
    });
  }

  renderTimers();
};


/* -------- RESET -------- */
window.resetTimer = async id => {
  if(!timers[id]) return;
  const prev = timers[id].elapsed || 0;

  timers[id].elapsed = 0;
  timers[id].running = false;
  timers[id].completed = false;
  timers[id].startedAtServer = null;

  await saveTimer(id, timers[id]);

  await logEvento(currentUid, "timer_reseteado", {
    timerId: id,
    prevElapsed: prev
  });

  renderTimers();
};


/* -------- DELETE -------- */
window.deleteTimer = async id => {
  if(!timers[id]) return;
  const t = timers[id];

  await removeTimerFromDb(id);
  delete timers[id];

  // quitar del order si existe y persistir
  const idx = timersOrder.indexOf(id);
  if(idx !== -1){
    timersOrder.splice(idx,1);
    await saveTimersOrder();
  }

  await logEvento(currentUid, "timer_borrado", {
    timerId: id,
    name: t.name,
    target: t.target,
    elapsed: t.elapsed
  });

  renderTimers();
};


/* -------- EDIT -------- */
window.editTimer = async id => {
  if(!timers[id]) return;
  const t = timers[id];

  const newTarget = Number(prompt("Nuevo objetivo en minutos:", t.target));
  if(!newTarget || newTarget <= 0) return;

  const old = t.target;
  t.target = newTarget;
  t.completed = false;

  await saveTimer(id, t);

  await logEvento(currentUid, "timer_editado", {
    timerId: id,
    cambios: { target: { antes: old, despues: newTarget } }
  });

  renderTimers();
};


/* -------- RENDER TICK (solo UI) -------- */
setInterval(() => {
  // revisar completados y loguearlos usando la hora real calculada
  const ids = Object.keys(timers);
  let needsSave = false;
  const completions = [];

  ids.forEach(id => {
    const t = timers[id];
    const elapsed = computeElapsedSec(t);
    if(!t.completed && elapsed >= (t.target * 60)){
      t.completed = true;
      completions.push({ id, elapsed });
      needsSave = true;
    }
  });

  // guardar cambios de completado (si los hay)
  if(needsSave){
    // guardamos cada timer completado individualmente
    completions.forEach(async c => {
      try {
        await saveTimer(c.id, timers[c.id]);
        await logEvento(currentUid, "timer_completado", {
          timerId: c.id,
          name: timers[c.id].name,
          elapsed: c.elapsed
        });
      } catch(e){
        console.error("Error guardando completion", e);
      }
    });
  }

  renderTimers();
}, 1000);


/* =======================
   ===== REGISTRO UI =====
   ======================= */

document.getElementById("refreshRegistroBtn").onclick = () => renderRegistroEventos();

async function renderRegistroEventos(){

  if(!currentUid){
    alert("Inicia sesi√≥n para ver el registro de eventos.");
    return;
  }

  const eventosRef = ref(db, `usuarios/${currentUid}/historialEventos`);

  if(lastEventosListener){
    lastEventosListener(); // cancelar
    lastEventosListener = null;
  }

  lastEventosListener = onValue(eventosRef, snap => {
    const raw = snap.val() || {};
    const eventosArr = Object.entries(raw).map(([key,val]) => ({ id:key, ...val }));
    eventosArr.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));

    // timersMeta extraction (from timer_creado events)
    const timersMeta = {};
    eventosArr.forEach(ev => {
      if(ev.tipo === "timer_creado" && ev.timerId){
        timersMeta[ev.timerId] = {
          name: ev.name || ev.timerId,
          target: ev.target || null,
          createdAt: ev.timestamp
        };
      }
    });

    // dias pairing
    const dias = [];
    const inicios = eventosArr.filter(e => e.tipo === "dia_iniciado");
    const finales = eventosArr.filter(e => e.tipo === "dia_finalizado");

    let usedFinalIndexes = new Set();
    inicios.forEach((inicio, idx) => {
      const inicioTs = new Date(inicio.timestamp);
      let matchedFinal = null;
      for(let j=0;j<finales.length;j++){
        if(usedFinalIndexes.has(j)) continue;
        const f = finales[j];
        const fTs = new Date(f.timestamp);
        if(fTs >= inicioTs){
          matchedFinal = { event: f, index: j };
          usedFinalIndexes.add(j);
          break;
        }
      }
      dias.push({
        dia: dias.length + 1,
        inicio: inicio.timestamp,
        fin: matchedFinal ? matchedFinal.event.timestamp : null,
        rawInicioEvent: inicio,
        rawFinEvent: matchedFinal ? matchedFinal.event : null
      });
    });

    function findDiaForTimestamp(ts){
      const t = new Date(ts);
      for(const d of dias){
        const start = new Date(d.inicio);
        const end = d.fin ? new Date(d.fin) : null;
        if(end){
          if(t >= start && t <= end) return d.dia;
        } else {
          if(t >= start) return d.dia;
        }
      }
      return null;
    }

    const eventosParaTabla = eventosArr;

    const filas = eventosParaTabla.map(ev => {
      const dia = findDiaForTimestamp(ev.timestamp);
      const timerId = ev.timerId || null;
      const meta = timerId && timersMeta[timerId] ? timersMeta[timerId] : null;

      let elapsedSec = null;
      if(ev.elapsed !== undefined && ev.elapsed !== null) elapsedSec = ev.elapsed;
      else if(ev.elapsedAntes !== undefined && ev.elapsedAntes !== null) elapsedSec = ev.elapsedAntes;
      else if(ev.prevElapsed !== undefined && ev.prevElapsed !== null) elapsedSec = ev.prevElapsed;

      const objetivo = meta ? meta.target : (ev.target || null);
      const nombre = ev.name || (meta ? meta.name : (timerId || ""));

      return {
        id: ev.id || `${ev.tipo}-${ev.timestamp}`,
        dia,
        tipo: ev.tipo,
        nombre,
        marca: elapsedSec,
        marcaStr: formatTimeFromSeconds(elapsedSec),
        timestamp: ev.timestamp,
        objetivo,
        creado: meta ? meta.createdAt : (ev.createdAt || ""),
        raw: ev
      };
    });

    filas.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));

    // construir sesiones (start/pause/complete)
    (function createAndExposeRegistroProcesado(){
      const openMap = {};
      const sessions = [];
      function closeOpenSession(timerId, endEv, closingType){
        const o = openMap[timerId];
        if(!o) return;
        const startEv = o.startEv;
        const startTs = startEv.timestamp;
        const endTs = endEv.timestamp || new Date().toISOString();
        const startElapsed = startEv.elapsedAntes !== undefined ? startEv.elapsedAntes : (startEv.elapsed || null);
        const endElapsed = endEv.elapsed !== undefined ? endEv.elapsed : (endEv.elapsedAntes !== undefined ? endEv.elapsedAntes : null);
        const durationSec = Math.max(0, Math.floor((new Date(endTs) - new Date(startTs)) / 1000));

        let diaNum = null;
        for(const d of dias){
          const s = new Date(d.inicio);
          const e = d.fin ? new Date(d.fin) : null;
          const st = new Date(startTs);
          if(e){
            if(st >= s && st <= e){ diaNum = d.dia; break; }
          } else {
            if(st >= s){ diaNum = d.dia; break; }
          }
        }

        sessions.push({
          timerId: timerId || null,
          name: (startEv.name || (timersMeta && timersMeta[timerId] && timersMeta[timerId].name) || null),
          startTs,
          endTs,
          startElapsed: startElapsed !== undefined ? startElapsed : null,
          endElapsed: endElapsed !== undefined ? endElapsed : null,
          durationSec,
          dia: diaNum,
          dateKey: (startTs) ? new Date(startTs).toISOString().slice(0,10) : null,
          objetivoMin: (timersMeta && timersMeta[timerId] && timersMeta[timerId].target) ? Number(timersMeta[timerId].target) : (startEv && startEv.target ? Number(startEv.target) : null),
          closingType: closingType || (endEv && endEv.tipo) || null
        });

        delete openMap[timerId];
      }

      eventosArr.forEach(ev => {
        const tipo = ev.tipo;
        const tid = ev.timerId || null;
        if(tipo === "timer_iniciado" && tid){
          openMap[tid] = { startEv: ev };
        } else if(tid && (tipo === "timer_pausado" || tipo === "timer_reseteado" || tipo === "timer_completado" || tipo === "timer_borrado")){
          closeOpenSession(tid, ev, tipo);
        }
      });

      const nowIso = new Date().toISOString();
      Object.keys(openMap).forEach(timerId => {
        const openObj = openMap[timerId];
        const startTs = openObj.startEv.timestamp;
        let closed = false;
        for(const d of dias){
          const s = new Date(d.inicio);
          const e = d.fin ? new Date(d.fin) : null;
          const st = new Date(startTs);
          if(e && st >= s && st <= e){
            const fakeEndEv = { timestamp: d.fin, tipo: "auto_cierre_por_day_end" };
            closeOpenSession(timerId, fakeEndEv, "auto_cierre_por_day_end");
            closed = true;
            break;
          }
        }
        if(!closed){
          const fakeEndEv = { timestamp: nowIso, tipo: "auto_cierre_por_now" };
          closeOpenSession(timerId, fakeEndEv, "auto_cierre_por_now");
        }
      });

      window.registroProcesado = {
        dias: dias.map(d => ({
          dia: d.dia,
          inicio: d.inicio,
          fin: d.fin || null,
          dateKeys: d.rawInicioEvent && d.rawInicioEvent.timestamp ? [ (new Date(d.rawInicioEvent.timestamp)).toISOString().slice(0,10) ] : (d.dateKeys || [])
        })),
        sessions: sessions,
        timersMeta: timersMeta || {}
      };

      window.dispatchEvent(new CustomEvent('registroProcesadoReady', { detail: window.registroProcesado }));
    })();


    // RENDER TABLA
    const tbody = document.getElementById("registroBody");
    tbody.innerHTML = "";

    filas.forEach(f => {
      const tr = document.createElement("tr");
      if(f.dia === null) tr.classList.add("no-day");

      tr.innerHTML = `
        <td>${f.dia === null ? "<i>sin d√≠a asignado</i>" : f.dia}</td>
        <td>${escapeHtml(f.nombre || "")}</td>
        <td>${escapeHtml(f.tipo)}</td>
        <td>${f.marcaStr || ""}</td>
        <td>${formatLocal(f.timestamp)}</td>
        <td>${f.objetivo === null || f.objetivo === undefined ? "" : f.objetivo}</td>
        <td>${f.creado ? formatLocal(f.creado) : ""}</td>
      `;
      tbody.appendChild(tr);
    });

    if(dias.length === 0){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="7" class="small">No se detectaron pares dia_iniciado / dia_finalizado. Si existe un d√≠a en curso, aparecer√° como 'en curso' (fin vac√≠o).</td>`;
      tbody.prepend(tr);
    }

  }); // onValue
} // renderRegistroEventos


/* -------- D√çA -------- */

document.getElementById("startDayBtn").onclick = async () => {
  if(dayStarted) return alert("El d√≠a ya est√° iniciado.");
  dayStarted = serverTimestamp();
  dayEnded = null;
  await saveDay();

  logEvento(currentUid, "dia_iniciado", {
    dia: (new Date()).toISOString().slice(0,10),
    dayStarted
  });

  renderTimers();
};

document.getElementById("endDayBtn").onclick = async () => {
  if(!dayStarted) return alert("A√∫n no iniciaste el d√≠a.");
  dayEnded = serverTimestamp();

  // snapshot opcional
  const snapshot = {
    dayStarted,
    dayEnded,
    timersSnapshot: JSON.parse(JSON.stringify(timers))
  };

  // reiniciar estado local
  Object.keys(timers).forEach(k => {
    timers[k].running = false;
    timers[k].elapsed = 0;
    timers[k].completed = false;
    timers[k].startedAtServer = null;
  });

  await saveDay();

  logEvento(currentUid, "dia_finalizado", {
    dia: (new Date()).toISOString().slice(0,10),
    ...snapshot
  });

  renderTimers();
};


document.getElementById("addTimerBtn").onclick = () =>
  document.getElementById("formSection").classList.toggle("hidden");


/* -------- DRAG & DROP (compatible con timersOrder) -------- */

let draggedId = null;

function enableDragAndDrop(){
  const container = document.getElementById("timers-container");
  const children = Array.from(container.querySelectorAll(".timer"));

  children.forEach(child => {
    child.ondragstart = e => {
      draggedId = child.dataset.timerId;
      try { e.dataTransfer.setData("text/plain", draggedId); } catch(_) {}
    };

    child.ondragover = e => {
      e.preventDefault();
    };

    child.ondrop = e => {
      e.preventDefault();
      const dropTarget = e.target.closest(".timer");
      if(!dropTarget) return;

      const targetId = dropTarget.dataset.timerId;
      if(!draggedId || !targetId || draggedId === targetId) return;

      // reordenar timersOrder en memoria
      const fromIndex = timersOrder.indexOf(draggedId);
      const toIndex = timersOrder.indexOf(targetId);

      // Si timersOrder no contiene alguno (casos raros), reconstruir primero
      if(fromIndex === -1 || toIndex === -1){
        timersOrder = Array.from(container.querySelectorAll(".timer")).map(d => d.dataset.timerId);
      } else {
        timersOrder.splice(fromIndex, 1);
        const insertIndex = timersOrder.indexOf(targetId);
        timersOrder.splice(insertIndex, 0, draggedId);
      }

      // persistir
      saveTimersOrder().catch(e => console.error(e));

      // re-render UI con nuevo orden
      renderTimers();
      draggedId = null;
    };
  });
}

/* ===========================
   ====== FIN registro UI =====
   =========================== */

</script>

<!-- Conexi√≥n al archivo externo de estad√≠sticas -->
<script type="module" src="estadisticas.js"></script>

</body>
</html>










































































