<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Proyecto Armando - Reparado</title>

<style>
/* =============================
   ESTILOS BASE (IGUALES A INDEX 5)
   ============================= */
body {
  font-family: 'Segoe UI', sans-serif;
  background: #dbdace;
  color: #a1a1a1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

#dayHeader {
  background: #1a1a1a;
  border: 1px solid #333;
  padding: 15px;
  border-radius: 10px;
  width: 90%;
  max-width: 700px;
  color: #ddd;
  text-align: center;
  margin-bottom: 20px;
}

#dayHeader h2 {
  margin-bottom: 8px;
  color: #fff;
  font-size: 1.4rem;
}

#dayHeader p {
  margin: 4px 0;
  font-size: 1rem;
}

   
button {
  background: #3b5dd1;
  border: none;
  color: #f1f1f1;
  padding: 8px 14px;
  margin: 4px;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.3s;
}
button:hover { background: #5a7be0; }

/* =============================
   GRID DE CRON√ìMETROS
   ============================= */
#timers-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
  width: 90%;
  max-width: 900px;
}

/* =============================
   TARJETA DEL CRON√ìMETRO
   ============================= */
.timer {
  background: #1a2f7a;
  border: 1px solid #333;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.timer.completed {
  background: #164d16;
  border-color: #1d7a1d;
}

.timer p span {
  font-size: 2rem;
  font-weight: bold;
  color: #fff;
}

.timer h3 { margin: 5px 0; }
.timer p { margin: 2px 0; }

.timer .buttons {
  display: flex;
  gap: 6px;
}

.draggable { cursor: move; }

/* =============================
   LOGIN PANEL
   ============================= */
#loginPanel {
  background: #1c1c1c;
  padding: 20px;
  border-radius: 10px;
  border: 1px solid #333;
  text-align: center;
  margin-bottom: 25px;
}

#loginPanel input {
  width: 220px;
  margin: 5px 0;
}

/* =============================
   INPUTS Y FORMULARIOS
   ============================= */
.input-group {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  margin: 8px 0;
}

input, textarea {
  padding: 6px;
  border-radius: 5px;
  border: 1px solid #555;
  background: #181818;
  color: #eee;
}

textarea { resize: vertical; }

.hidden {
  display: none !important;
}

/* =============================
   MEN√ö SUPERIOR (IGUAL INDEX 5)
   ============================= */
#menu {
  position: fixed;
  top: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

/* =============================
   TABLA DE REGISTRO
   ============================= */
#registroTable {
  width: 95%;
  max-width: 1100px;
  border-collapse: collapse;
  margin-top: 12px;
  background: #f7f7f7;
  color: #111;
  border-radius: 8px;
  overflow: hidden;
}
#registroTable thead th {
  background: #3b5dd1;
  color: #fff;
  padding: 10px;
  text-align: left;
  font-weight: 600;
}
#registroTable tbody td {
  padding: 8px 10px;
  border-bottom: 1px solid #e0e0e0;
  font-size: .95rem;
}

.small { font-size: .9rem; color: #666; }
.no-day { background: #fff3cd !important; }

</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>


<body>
<h1>Proyecto Armando</h1>

   <div id="dayHeader" class="hidden">
  <h2 id="dayStartLabel"></h2>
  <p id="dayEstimation"></p>
  <p id="dayProgress"></p>
</div>


<div id="menu">
  <button onclick="openSection('mainPage')">üè† Cron√≥metros</button>
  <button onclick="openSection('registroEventos')">üìú Registro de eventos</button>
</div>


<!-- =============================
     SECCI√ìN PRINCIPAL
     ============================= -->
<section id="mainPage">
  <div id="dayInfo" class="hidden"></div>

  <div id="loginPanel">
    <h3>Acceso privado</h3>
    <input type="email" id="emailInput" placeholder="Correo autorizado">
    <input type="password" id="passwordInput" placeholder="Contrase√±a">
    <button id="loginEmailBtn">Ingresar</button>
    <p id="loginError" style="color:#ff5555;"></p>
  </div>

  <div id="userSection" class="hidden">
    <p id="userInfo"></p>
    <button id="logoutBtn">Cerrar sesi√≥n</button>
  </div>

  <div class="controls hidden" id="mainControls">
    <button id="startDayBtn">üåÖ Iniciar D√≠a</button>
    <button id="endDayBtn">üåá Finalizar D√≠a</button>
    <button id="addTimerBtn">‚ûï Nuevo Cron√≥metro</button>
  </div>

  <div id="formSection" class="hidden">
    <div class="input-group">
      <input type="text" id="activityName" placeholder="Nombre de la actividad">
      <input type="number" id="targetMinutes" placeholder="Minutos objetivo" min="1">
    </div>
    <div class="input-group">
      <textarea id="note" placeholder="Nota (opcional)"></textarea>
    </div>
    <button id="createTimerBtn">Crear</button>
  </div>

  <div id="timers-container"></div>
</section>



<!-- =============================
     REGISTRO DE EVENTOS + ESTAD√çSTICAS
     ============================= -->
<section id="registroEventos" class="hidden">
  <h2>üìú Registro de eventos (historial)</h2>

  <div id="statsWrapper" style="margin-top:25px; width:90%; max-width:1100px;">
    <h2 style="margin-top:25px;">üìà Estad√≠sticas</h2>

    <div class="card small" style="background:#eef; padding:10px; border-radius:8px;">
      Datos generados autom√°ticamente a partir del historial de eventos.
    </div>

    <div class="card" style="padding:10px; background:#fff; border-radius:8px; margin:10px 0;">
      <h3>Filtros</h3>
      <select id="filterDia"><option value="">Todos los d√≠as</option></select>
      <select id="filterFecha"><option value="">Todas las fechas</option></select>
      <select id="filterActividad"><option value="">Todas las actividades</option></select>
      <select id="filterWeek"><option value="">Todas las semanas</option></select>
      <select id="filterMonth"><option value="">Todos los meses</option></select>
      <select id="filterYear"><option value="">Todos los a√±os</option></select>
      <button id="refreshStatsBtn">üîÅ Actualizar</button>
      <div id="statsStatus" style="font-size:12px; color:#555; margin-top:5px;"></div>
    </div>

    <div class="card" style="padding:10px; background:#fff; border-radius:8px; margin:10px 0;">
      <h3>Resumen</h3>
      <div id="statsResumen" class="small"></div>
    </div>

    <div class="card" style="padding:10px; background:#fff; border-radius:8px; margin:10px 0;">
      <h3>Tiempo por actividad</h3>
      <canvas id="chartActividades" height="120"></canvas>
    </div>

    <div class="card" style="padding:10px; background:#fff; border-radius:8px; margin:10px 0;">
      <h3>Tiempo por d√≠a</h3>
      <canvas id="chartDias" height="120"></canvas>
    </div>
  </div>

  <div id="registroWrapper">
    <div id="registroControls">
      <span class="small">Se muestran eventos sincronizados desde Firebase y asignados a d√≠as de trabajo.</span>
      <button id="refreshRegistroBtn">üîÅ Refrescar ahora</button>
    </div>

    <table id="registroTable">
      <thead>
        <tr>
          <th>D√≠a</th>
          <th>Cron√≥metro</th>
          <th>Acci√≥n</th>
          <th>Marca</th>
          <th>Fecha y hora</th>
          <th>Objetivo (min)</th>
          <th>Creado</th>
          <th>Cumplido</th>
        </tr>
      </thead>
      <tbody id="registroBody"></tbody>
    </table>
  </div>
</section>


<script type="module">
// ---------------- Variables globales ----------------
let filas = [];
let eventosRefGlobal = null;
let lastEventosListener = null;
let sessionMapByStart = {};
let registroProcesado = null;
let chartAct = null, chartDia = null;

// ---------------- Firebase imports ----------------
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getDatabase, ref, set, onValue, push } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyCby9oxzPzBDllkzuW21ZoGNJh67UgYZ8E",
  authDomain: "notion-timers-2a3bb.firebaseapp.com",
  databaseURL: "https://notion-timers-2a3bb-default-rtdb.firebaseio.com",
  projectId: "notion-timers-2a3bb",
  storageBucket: "notion-timers-2a3bb.firebasestorage.app",
  messagingSenderId: "78500747038",
  appId: "1:78500747038:web:2b5fdec3731a203c7f1b0f"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

// ---------------- Conserva la secci√≥n de cron√≥metros (no alterada) ----------------
let dbRef;
let timers = [];
let dayStarted = null;
let dayEnded = null;
let currentUid = null;
const loggedCompletions = new Set();

//aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   // Mapa global para asignar un color persistente por actividad
const activityColors = {};
function getActivityColor(name){
  if(!activityColors[name]){
    // Generar color pastel consistente
    let hash = 0;
    for (let i = 0; i < name.length; i++){
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const hue = Math.abs(hash) % 360;
    activityColors[name] = `hsl(${hue}, 70%, 85%)`;
  }
  return activityColors[name];
}


   
document.getElementById("loginEmailBtn").onclick = async () => {
  const email = document.getElementById("emailInput").value;
  const pass = document.getElementById("passwordInput").value;
  try { await signInWithEmailAndPassword(auth, email, pass); }
  catch(e){ document.getElementById("loginError").textContent="Credenciales incorrectas"; console.error(e); }
};
document.getElementById("logoutBtn").onclick = () => signOut(auth);

onAuthStateChanged(auth, user => {
  if(user){
    currentUid = user.uid;
    document.getElementById("loginPanel").classList.add("hidden");
    document.getElementById("userSection").classList.remove("hidden");
    document.getElementById("mainControls").classList.remove("hidden");
    document.getElementById("userInfo").textContent = `Conectado como: ${user.email}`;
    dbRef = ref(db, `usuarios/${user.uid}/cronometros/diaActual`);
    listen();
    eventosRefGlobal = ref(db, `usuarios/${user.uid}/historialEventos`);
  } else {
    currentUid = null;
    dbRef = null;
    document.getElementById("loginPanel").classList.remove("hidden");
    document.getElementById("userSection").classList.add("hidden");
    document.getElementById("mainControls").classList.add("hidden");
    timers = [];
    renderTimers();
  }
});

function listen(){
  onValue(dbRef, snap => {
    const data = snap.val() || {};
    timers = data.timers || [];
    dayStarted = data.dayStarted || null;
    dayEnded = data.dayEnded || null;
    loggedCompletions.clear();
    renderTimers();
  });
}
async function save(){
  if(!dbRef) return;
  try{ await set(dbRef, { timers, dayStarted, dayEnded, updatedAt:new Date().toISOString() }); }
  catch(e){ console.error("Error guardando:", e); }
}

async function logEvento(uid, tipo, dataExtra = {}) {
  if(!uid) return;
  try{
    const eventosRef = ref(db, `usuarios/${uid}/historialEventos`);
    const evento = { timestamp: new Date().toISOString(), tipo, usuario: uid, ...dataExtra };
    const newRef = push(eventosRef);
    await set(newRef, evento);
  }catch(e){ console.error("Error logeando evento:", e); }
}

function formatTimeFromSeconds(s){
  if(s == null || s === undefined) return "";
  s = Number(s); if(isNaN(s)) return "";
  const h = String(Math.floor(s/3600)).padStart(2,"0");
  const m = String(Math.floor((s%3600)/60)).padStart(2,"0");
  const s2 = String(s%60).padStart(2,"0");
  return `${h}:${m}:${s2}`;
}
function formatLocal(ts){
  try { return new Date(ts).toLocaleString(); } catch(e){ return ts; }
}
function escapeHtml(unsafe){
  if(!unsafe && unsafe !== 0) return "";
  return String(unsafe).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

// UI nav
window.openSection = function(sectionId){
  document.getElementById("mainPage").classList.add("hidden");
  document.getElementById("registroEventos").classList.add("hidden");
  document.getElementById(sectionId).classList.remove("hidden");
  if(sectionId === "registroEventos") setTimeout(()=> renderRegistroEventos(), 20);
};

// Timers UI (kept from original)
document.getElementById("createTimerBtn").onclick = async () => {
  const n = document.getElementById("activityName").value.trim();
  const t = Number(document.getElementById("targetMinutes").value);
  const note = document.getElementById("note").value.trim();
  if(!n || !t) return alert("Nombre y minutos requeridos.");
  const createdAt = new Date().toISOString();
  const newTimer = { name:n, target:t, note, elapsed:0, running:false, completed:false, createdAt };
  timers.push(newTimer);
  document.getElementById("activityName").value="";
  document.getElementById("targetMinutes").value="";
  document.getElementById("note").value="";
  document.getElementById("formSection").classList.add("hidden");
  await save();
  logEvento(currentUid, "timer_creado", { timerId: createdAt, name: n, targetMin: t, note });
  renderTimers();
   updateDayHeader();
};
function renderTimers(){
  const container = document.getElementById("timers-container");
  container.innerHTML = "";
  const totalTargetSeconds = timers.reduce((sum,t)=> sum + (t.target||0)*60, 0);
  const totalElapsedSeconds = timers.reduce((sum,t)=> {
    let display = Number(t.elapsed) || 0;
    if(t.running && t.startedAt) display += Math.floor((new Date() - new Date(t.startedAt)) / 1000);
    return sum + display;
  }, 0);
  const dayInfoDiv = document.getElementById("dayInfo");
  if(dayStarted){
    const start = new Date(dayStarted);
    const estimatedEnd = new Date(start.getTime() + totalTargetSeconds*1000);
    const progress = totalTargetSeconds ? totalElapsedSeconds / totalTargetSeconds * 100 : 0;
    dayInfoDiv.innerHTML = `<p>D√≠a iniciado: ${start.toLocaleString()}</p>
      <p>Hora estimada de fin: ${estimatedEnd.toLocaleString()}</p>
      <p>Progreso total: ${progress.toFixed(1)}%</p>`;
    dayInfoDiv.classList.remove("hidden");
  } else dayInfoDiv.classList.add("hidden");
  timers.forEach((t,i)=>{
    const div = document.createElement("div");
    div.className = "timer draggable" + (t.completed ? " completed" : "");
    div.draggable = true;
    let displayElapsed = Number(t.elapsed)||0;
    if(t.running && t.startedAt) displayElapsed += Math.floor((new Date() - new Date(t.startedAt)) / 1000);
    const pctObj = t.target ? ((displayElapsed / (t.target*60))*100).toFixed(1) : "0.0";
    const pctTotal = totalTargetSeconds ? ((displayElapsed / totalTargetSeconds)*100).toFixed(1) : "0.0";
    div.innerHTML = `<h3>${escapeHtml(t.name)}</h3>
      <p><span>${formatTimeFromSeconds(displayElapsed)}</span></p>
      <p>Objetivo: ${t.target} min</p>
      <p>Progreso espec√≠fico: ${pctObj}%</p>
      <p>Progreso general: ${pctTotal}%</p>
      <p>Creado: ${new Date(t.createdAt).toLocaleString()}</p>
      ${t.note ? `<p><i>${escapeHtml(t.note)}</i></p>` : ""}
      <div class="buttons">
        <button onclick="toggleTimer(${i})">${t.running? "‚è∏Ô∏è Pausa":"‚ñ∂Ô∏è Iniciar"}</button>
        <button onclick="resetTimer(${i})">üîÑ Reset</button>
        <button onclick="deleteTimer(${i})">üóëÔ∏è Borrar</button>
        <button onclick="editTimer(${i})">‚úèÔ∏è Editar</button>
      </div>`;
    container.appendChild(div);
  });
  enableDragAndDrop();
}
setInterval(async ()=>{
  if(!timers || timers.length===0) return;
  const now = new Date();
  let needsSave = false;
  timers.forEach(t=>{
    if(t.running && t.startedAt){
      const elapsedReal = t.elapsed + Math.floor((now - new Date(t.startedAt))/1000);
      if(!t.completed && t.target && elapsedReal >= t.target*60){
        t.completed = true; needsSave = true;
        logEvento(currentUid,"timer_completado",{ timerId: t.createdAt, name: t.name, endElapsed: elapsedReal});
      }
    }
  });
  if(needsSave) await save();
  renderTimers();
   updateDayHeader();
},1000);

window.editTimer = async i => {
  const newTarget = prompt("Nuevo objetivo en minutos:", timers[i].target);
  if(!newTarget || isNaN(newTarget) || newTarget<=0) return;
  timers[i].target = Number(newTarget);
  timers[i].completed = false;
  await save();
  logEvento(currentUid,"timer_editado",{ timerId: timers[i].createdAt, name: timers[i].name, targetMin: timers[i].target });
  renderTimers();
};

 
window.toggleTimer = async i => {
  if(!dayStarted) return alert("Primero inicia el d√≠a.");
  const t = timers[i];
  const timerId = t.createdAt;
  if(!t.running){
    t.running = true; t.startedAt = new Date().toISOString(); await save();
    logEvento(currentUid,"timer_iniciado",{ timerId, name: t.name, startElapsed: t.elapsed });
  } else {
    const nowIso = new Date().toISOString();
    if(t.startedAt){
      const deltaSec = Math.floor((new Date(nowIso) - new Date(t.startedAt))/1000);
      t.elapsed += Math.max(0, deltaSec); delete t.startedAt;
    }
    t.running = false; await save();
    logEvento(currentUid,"timer_pausado",{ timerId, name: t.name, endElapsed: t.elapsed });
  }
  renderTimers();
};

window.resetTimer = async i => {
  const prevElapsed = timers[i].elapsed;
  const timerId = timers[i].createdAt;
  timers[i].elapsed = 0; timers[i].running = false; timers[i].completed = false;
  await save();
  logEvento(currentUid,"timer_reseteado",{ timerId, name: timers[i].name, prevElapsed, endElapsed:0 });
  renderTimers();
};

window.deleteTimer = async i => {
  const timer = timers[i];
  timers.splice(i,1); await save();
  logEvento(currentUid,"timer_borrado",{ timerId: timer.createdAt, name: timer.name, target: timer.target, elapsed: timer.elapsed });
  renderTimers();
};

let draggedIndex = null;
function enableDragAndDrop(){
  const container = document.getElementById("timers-container");
  const children = container.querySelectorAll(".timer");
  children.forEach(child=>{
    child.ondragstart = e => { draggedIndex = [...children].indexOf(e.target); };
    child.ondragover = e => e.preventDefault();
    child.ondrop = e => {
      const targetIndex = [...children].indexOf(e.target.closest(".timer"));
      if(targetIndex===-1 || draggedIndex===null) return;
      const moved = timers.splice(draggedIndex,1)[0];
      timers.splice(targetIndex,0,moved);
      draggedIndex=null; save(); renderTimers();
    };
  });
}

// day buttons
document.getElementById("startDayBtn").onclick = async () => {
  if(dayStarted) return alert("El d√≠a ya est√° iniciado.");
  dayStarted = new Date().toISOString(); dayEnded = null; await save();
  logEvento(currentUid,"dia_iniciado",{ dia: (new Date()).toISOString().slice(0,10), dayStarted });
  renderTimers();
    updateDayHeader();
};
document.getElementById("endDayBtn").onclick = async () => {
  if(!dayStarted) return alert("A√∫n no iniciaste el d√≠a.");
  dayEnded = new Date().toISOString();
  const snapshot = { dayStarted, dayEnded, timersSnapshot: JSON.parse(JSON.stringify(timers)) };
  timers.forEach(t=>{ t.running=false; t.elapsed=0; t.completed=false; });
  dayStarted = null; await save();
  logEvento(currentUid,"dia_finalizado",{ dia:(new Date()).toISOString().slice(0,10), ...snapshot });
  renderTimers();
};
document.getElementById("addTimerBtn").onclick = () => document.getElementById("formSection").classList.toggle("hidden");

// ---------------- Registro y Estad√≠sticas (reconstruido) ----------------

// helper to safely parse/normalize timestamp to ISO string
function normalizeTimestamp(ts){
  if(!ts && ts!==0) return null;
  if(typeof ts === 'number') return new Date(ts).toISOString();
  if(typeof ts === 'string'){
    const d = new Date(ts);
    if(!isNaN(d)) return d.toISOString();
    return ts; // leave as-is
  }
  return null;
}

// process events -> sessions and days
// process events -> sessions and days
function processEventsToRegistro(eventosArr){
  // sanitize, map to objects and normalize timestamps
  const evs = (eventosArr||[]).filter(e=> e && typeof e === 'object').map(e => ({...e, timestamp: normalizeTimestamp(e.timestamp)}));

  // build name->targetMin mapping from timer_creado events (user requested: match by name)
  const objetivoPorNombre = {};
  const metaByTimerId = {};
  evs.forEach(ev=>{
    if(ev.tipo === 'timer_creado'){
      const name = ev.name || null;
      if(name && ev.targetMin!==undefined && ev.targetMin!==null){
        objetivoPorNombre[name] = Number(ev.targetMin);
      }
      if(ev.timerId){
        metaByTimerId[ev.timerId] = { name: ev.name || ev.timerId, targetMin: ev.targetMin ?? null, createdAt: ev.timestamp ?? null };
      }
    }
  });

  // extract day intervals (pair dia_iniciado / dia_finalizado)
  const dias = [];
  const inicios = evs.filter(e=>e.tipo==='dia_iniciado').sort((a,b)=> Date.parse(a.timestamp||0) - Date.parse(b.timestamp||0));
  const finales = evs.filter(e=>e.tipo==='dia_finalizado').sort((a,b)=> Date.parse(a.timestamp||0) - Date.parse(b.timestamp||0));
  let usedFinal = new Set();
  inicios.forEach(ini=>{
    const inicioTs = Date.parse(ini.timestamp || 0);
    let matched = null;
    for(let j=0;j<finales.length;j++){
      if(usedFinal.has(j)) continue;
      const f = finales[j];
      const fTs = Date.parse(f.timestamp || 0);
      if(fTs >= inicioTs){ matched = f; usedFinal.add(j); break; }
    }
    dias.push({ dia: dias.length+1, inicio: ini.timestamp, fin: matched? matched.timestamp:null, rawInicio: ini, rawFin: matched||null });
  });

  // helper to determine which day a timestamp belongs to
  function findDiaForTs(ts){
    if(!ts) return null;
    const t = Date.parse(ts);
    for(const d of dias){
      const s = Date.parse(d.inicio || 0);
      const e = d.fin ? Date.parse(d.fin) : null;
      if(e){
        if(t>=s && t<=e) return d.dia;
      } else {
        if(t>=s) return d.dia;
      }
    }
    return null;
  }

  // --- Build sessions using marks (marca_i - marca_i-1) grouped by timerId ---
  const sessions = [];
  const eventosPorTimer = {};

  // group events by timerId (ignore events without timerId except we still keep rawEvents)
  evs.forEach(ev => {
    const tid = ev.timerId;
    if(!tid) return;
    if(!eventosPorTimer[tid]) eventosPorTimer[tid] = [];
    eventosPorTimer[tid].push(ev);
  });

  // process each timer's list
  Object.keys(eventosPorTimer).forEach(tid => {
    const lista = eventosPorTimer[tid];

    // order by timestamp asc (robusto)
    lista.sort((a,b) => {
      const ta = a.timestamp ? Date.parse(a.timestamp) : 0;
      const tb = b.timestamp ? Date.parse(b.timestamp) : 0;
      return ta - tb;
    });

    // walk consecutive pairs and compute duration = marca(curr) - marca(prev)
    for(let i=1; i<lista.length; i++){
      const prev = lista[i-1];
      const curr = lista[i];

      // extract marks preferring endElapsed, then startElapsed, then elapsed
      const pMark = (prev.endElapsed !== undefined && prev.endElapsed !== null) ? Number(prev.endElapsed)
                   : (prev.startElapsed !== undefined && prev.startElapsed !== null) ? Number(prev.startElapsed)
                   : (prev.elapsed !== undefined && prev.elapsed !== null) ? Number(prev.elapsed)
                   : null;

      const cMark = (curr.endElapsed !== undefined && curr.endElapsed !== null) ? Number(curr.endElapsed)
                   : (curr.startElapsed !== undefined && curr.startElapsed !== null) ? Number(curr.startElapsed)
                   : (curr.elapsed !== undefined && curr.elapsed !== null) ? Number(curr.elapsed)
                   : null;

      if(pMark != null && cMark != null){
        let dur = Math.max(0, Math.floor(cMark - pMark)); // seconds
        // compute name (prefer explicit name fields, else metadata)
        const name = curr.name || prev.name || (metaByTimerId[tid] && metaByTimerId[tid].name) || tid;
        // objetivo: prefer objetivoPorNombre by name, else metaByTimerId targetMin, else null
        let objetivoMin = null;
        if(name && objetivoPorNombre[name] !== undefined) objetivoMin = Number(objetivoPorNombre[name]);
        else if(metaByTimerId[tid] && metaByTimerId[tid].targetMin !== undefined && metaByTimerId[tid].targetMin !== null) objetivoMin = Number(metaByTimerId[tid].targetMin);
        else if(prev.target !== undefined) objetivoMin = Number(prev.target);

        const diaNum = findDiaForTs(prev.timestamp);
        const dateKey = prev.timestamp ? (new Date(prev.timestamp)).toISOString().slice(0,10) : null;

        sessions.push({
          timerId: tid,
          name,
          startTs: prev.timestamp || null,
          endTs: curr.timestamp || null,
          startElapsed: pMark,
          endElapsed: cMark,
          durationSec: dur,
          dia: diaNum,
          dateKey,
          objetivoMin,
          closingType: curr.tipo || null
        });
      }
      // if marks missing, skip pair (can't compute duration)
    }
  });

  // Note: we intentionally DO NOT try to auto-close open sessions by timestamp here using openMap.
  // If you want an "open" session closing at day end/now, we could add it ‚Äî but durations based on marks require a following mark.

  // prepare registro object (compatible with rest of your code)
  return {
    dias: dias.map(d=>({ dia:d.dia, inicio:d.inicio, fin:d.fin||null })),
    sessions,
    objetivoPorNombre,
    metaByTimerId,
    rawEvents: evs
  };
}


// build table rows and apply filters (filters will also filter table)
function buildAndRenderTable(registro, filters){
  // registry.sessions is authoritative for durations; but we also want to show all raw events
  const raw = registro.rawEvents || [];
  // create map from event id or timestamp to session (so we can mark durations near timer_pausado)
  const sessionByStart = {};
  registro.sessions.forEach(s=>{
    if(s.startTs) sessionByStart[s.startTs] = s;
  });

  // generate rows for each raw event
  const rows = raw.map(ev => {
    const ts = ev.timestamp || null;
    const dia = findDiaForEvent(ts, registro.dias);

    const name =
      ev.name ||
      (ev.timerId &&
        registro.metaByTimerId &&
        registro.metaByTimerId[ev.timerId] &&
        registro.metaByTimerId[ev.timerId].name) ||
      ev.timerId ||
      "";

    let objetivo = null;


    // --- SEGUNDO: por nombre (unifica actividades repetidas)
    if (name && registro.objetivoPorNombre[name] !== undefined) {
    objetivo = Number(registro.objetivoPorNombre[name]);
} else {
    objetivo = null;
}

    // compute marcaStr
    const marca = ev.endElapsed ?? ev.elapsed ?? null;
    const marcaStr =
      marca !== null ? formatTimeFromSeconds(Number(marca)) : "";

    // match session
    let matchedSession = null;

    // MATCH 1 ‚Äî cerrado EXACTO (evento final)
    matchedSession = registro.sessions.find(
      (s) => s.endTs && ev.timestamp && s.endTs === ev.timestamp
    );

    // MATCH 2 ‚Äî si evento es INICIO
    if (!matchedSession) {
      matchedSession = registro.sessions.find(
        (s) => s.startTs && ev.timestamp && s.startTs === ev.timestamp
      );
    }

    // MATCH 3 ‚Äî por rango
    if (!matchedSession) {
      const evTime = ev.timestamp ? Date.parse(ev.timestamp) : null;
      if (evTime) {
        matchedSession = registro.sessions.find((s) => {
          if (!s.startTs || !s.endTs) return false;
          const st = Date.parse(s.startTs);
          const en = Date.parse(s.endTs);
          return evTime >= st && evTime <= en;
        });
      }
    }

    const dur = matchedSession ? matchedSession.durationSec : null;

    const cumplido = (() => {
      const objMin = objetivo;
      if (objMin === null || objMin === undefined) return false;
      const targetSec = Number(objMin) * 60;
      if (dur !== null && dur !== undefined) return dur >= targetSec;
      if (marca !== null && !isNaN(Number(marca)))
        return Number(marca) >= targetSec;
      return false;
    })();

    return {
      id: ev.id || ev.tipo + "-" + (ev.timestamp || Math.random()),
      dia,
      nombre: name,
      tipo: ev.tipo,
      marca,
      marcaStr,
      timestamp: ts,
      objetivo,
      creado: ev.createdAt || ev.timestamp || "",
      cumplido,
    };
});


  // apply filters to rows (filters object)
  let filtered = rows.slice();
  if(filters){
    if(filters.dia) filtered = filtered.filter(r => String(r.dia) === String(filters.dia));
    if(filters.fecha) filtered = filtered.filter(r => r.timestamp && r.timestamp.startsWith(filters.fecha));
    if(filters.actividad) filtered = filtered.filter(r => r.nombre === filters.actividad);
    if(filters.week) filtered = filtered.filter(r => r.timestamp && weekOfDate(r.timestamp) === filters.week);
    if(filters.month) filtered = filtered.filter(r => r.timestamp && (new Date(r.timestamp)).toISOString().slice(0,7) === filters.month);
    if(filters.year) filtered = filtered.filter(r => r.timestamp && (new Date(r.timestamp)).getFullYear().toString() === filters.year);
  }

  // render tbody
  const tbody = document.getElementById("registroBody");
  tbody.innerHTML = "";
  filtered.forEach(f=>{
    const tr = document.createElement("tr");
if(f.nombre){
  tr.style.backgroundColor = getActivityColor(f.nombre);
}

    if(f.dia === null) tr.classList.add("no-day");
    tr.innerHTML = `<td>${f.dia===null? "<i>sin d√≠a asignado</i>": f.dia}</td>
      <td>${escapeHtml(f.nombre||"")}</td>
      <td>${escapeHtml(f.tipo||"")}</td>
      <td>${f.marcaStr || ""}</td>
      <td>${f.timestamp ? formatLocal(f.timestamp) : ""}</td>
      <td>${f.objetivo ?? ""}</td>
      <td>${f.creado? formatLocal(f.creado): ""}</td>
      <td>${f.cumplido? "‚úî":"‚úñ"}</td>`;
    tbody.appendChild(tr);
  });

  // update stats view (we'll reuse refrescarEstadisticas which reads from registroProcesado and filters)
  refrescarEstadisticas(); // will apply same filters to charts
}

// helper to determine dia for event using dias array
function findDiaForEvent(ts, diasArr){
  if(!ts) return null;
  try{
    const t = Date.parse(ts);
    for(const d of diasArr){
      const s = Date.parse(d.inicio || 0);
      const e = d.fin ? Date.parse(d.fin) : null;
      if(e){
        if(t>=s && t<=e) return d.dia;
      } else {
        if(t>=s) return d.dia;
      }
    }
  }catch(e){}
  return null;
}

// week helper: return YYYY-Www string
function weekOfDate(isoTs){
  if(!isoTs) return null;
  const d = new Date(isoTs);
  // get ISO week number
  const target = new Date(d.valueOf());
  const dayNr = (d.getUTCDay() + 6) % 7;
  target.setUTCDate(target.getUTCDate() - dayNr + 3);
  const firstThursday = target.valueOf();
  target.setUTCMonth(0,1);
  if(target.getUTCDay() !== 4) target.setUTCDate(1 + ((4 - target.getUTCDay()) + 7) % 7);
  const weekNumber = 1 + Math.ceil((firstThursday - target) / 604800000);
  return `${d.getUTCFullYear()}-W${String(weekNumber).padStart(2,'0')}`;
}

// init stats UI
function initStatsUI(){
  if(!registroProcesado) return;
  const fd = document.getElementById("filterDia");
  const ff = document.getElementById("filterFecha");
  const fa = document.getElementById("filterActividad");
  const fw = document.getElementById("filterWeek");
  const fm = document.getElementById("filterMonth");
  const fy = document.getElementById("filterYear");
  // reset
  fd.innerHTML = `<option value="">Todos los d√≠as</option>`;
  ff.innerHTML = `<option value="">Todas las fechas</option>`;
  fa.innerHTML = `<option value="">Todas las actividades</option>`;
  fw.innerHTML = `<option value="">Todas las semanas</option>`;
  fm.innerHTML = `<option value="">Todos los meses</option>`;
  fy.innerHTML = `<option value="">Todos los a√±os</option>`;
  // days
  registroProcesado.dias.sort((a,b)=>a.dia-b.dia).forEach(d=> fd.innerHTML += `<option value="${d.dia}">D√≠a ${d.dia}</option>`);
  // fechas unique from sessions' dateKey
  const fechas = [...new Set(registroProcesado.sessions.map(s=>s.dateKey).filter(x=>x))].sort();
  fechas.forEach(f=> ff.innerHTML += `<option value="${f}">${f}</option>`);
  // actividades from sessions names
  const acts = [...new Set(registroProcesado.sessions.map(s=>s.name).filter(x=>x))].sort();
  acts.forEach(a=> fa.innerHTML += `<option value="${a}">${a}</option>`);
  // weeks
  const weeks = [...new Set(registroProcesado.sessions.map(s=> s.startTs ? weekOfDate(s.startTs) : null).filter(x=>x))].sort();
  weeks.forEach(w=> fw.innerHTML += `<option value="${w}">${w}</option>`);
  // months
  const months = [...new Set(registroProcesado.sessions.map(s=> s.startTs ? (new Date(s.startTs)).toISOString().slice(0,7) : null).filter(x=>x))].sort();
  months.forEach(m=> fm.innerHTML += `<option value="${m}">${m}</option>`);
  // years
  const years = [...new Set(registroProcesado.sessions.map(s=> s.startTs ? String((new Date(s.startTs)).getFullYear()) : null).filter(x=>x))].sort();
  years.forEach(y=> fy.innerHTML += `<option value="${y}">${y}</option>`);
}

// filters -> object
function readFilters(){
  return {
    dia: document.getElementById("filterDia").value || null,
    fecha: document.getElementById("filterFecha").value || null,
    actividad: document.getElementById("filterActividad").value || null,
    week: document.getElementById("filterWeek").value || null,
    month: document.getElementById("filterMonth").value || null,
    year: document.getElementById("filterYear").value || null
  };
}

// refrescarEstadisticas draws charts using registroProcesado and current filters
function refrescarEstadisticas(){
  if(!registroProcesado) return;
  const filters = readFilters();
  // reuse filtrarStats logic: filter sessions
  let lista = registroProcesado.sessions.slice();
  if(filters.dia) lista = lista.filter(s=> String(s.dia) === String(filters.dia));
  if(filters.fecha) lista = lista.filter(s=> s.dateKey === filters.fecha);
  if(filters.actividad) lista = lista.filter(s=> s.name === filters.actividad);
  if(filters.week) lista = lista.filter(s=> weekOfDate(s.startTs) === filters.week);
  if(filters.month) lista = lista.filter(s=> s.startTs ? (new Date(s.startTs)).toISOString().slice(0,7) === filters.month : false);
  if(filters.year) lista = lista.filter(s=> s.startTs ? String((new Date(s.startTs)).getFullYear()) === filters.year : false);

  document.getElementById("statsStatus").innerText = `Mostrando ${lista.length} sesiones`;

  const total = lista.reduce((a,b)=> a + (b.durationSec||0), 0);
  document.getElementById("statsResumen").innerHTML = `<p><b>Tiempo total:</b> ${formatTimeFromSeconds(total)}</p><p><b>D√≠as en marcha:</b> ${[...new Set(lista.map(s=>s.dia).filter(x=>x!=null))].length}</p>`;

  // actividad chart
  const act = {};
  lista.forEach(s => act[s.name] = (act[s.name]||0) + (s.durationSec||0));
  if(chartAct) try{ chartAct.destroy(); }catch(e){}
  chartAct = new Chart(document.getElementById("chartActividades"), { type:'bar', data:{ labels:Object.keys(act), datasets:[{ label:'segundos', data:Object.values(act) }] } });

  // dia chart
  const dia = {};
  lista.forEach(s => { if(s.dia!==null && s.dia!==undefined) dia[s.dia] = (dia[s.dia]||0) + (s.durationSec||0); });
  if(chartDia) try{ chartDia.destroy(); }catch(e){}
  chartDia = new Chart(document.getElementById("chartDias"), { type:'line', data:{ labels:Object.keys(dia).map(d=>"D√≠a "+d), datasets:[{ label:'segundos', data:Object.values(dia), tension:0.25 }] } });
}

// wire filters events
setTimeout(()=>{
  const fd = document.getElementById("filterDia");
  const ff = document.getElementById("filterFecha");
  const fa = document.getElementById("filterActividad");
  const fw = document.getElementById("filterWeek");
  const fm = document.getElementById("filterMonth");
  const fy = document.getElementById("filterYear");
  const fr = document.getElementById("refreshStatsBtn");
  [fd,ff,fa,fw,fm,fy].forEach(el=>{
    if(el) el.onchange = () => {
      // rebuild table with current filters
      buildAndRenderTable(registroProcesado, readFilters());
    };
  });
  if(fr) fr.onclick = () => { buildAndRenderTable(registroProcesado, readFilters()); };
},50);

// renderRegistroEventos: read firebase, process and render
function renderRegistroEventos(){
  if(!currentUid){ alert("Inicia sesi√≥n para ver el registro de eventos."); return; }
  const eventosRef = ref(db, `usuarios/${currentUid}/historialEventos`);
  if(lastEventosListener){ lastEventosListener(); lastEventosListener = null; }
  lastEventosListener = onValue(eventosRef, snap => {
    try{
      const raw = snap.val() || {};
      const eventosArr = Object.entries(raw).map(([key,val]) => ({ id:key, ...val }));
      // sort by timestamp robustly
      eventosArr.sort((a,b)=> {
        const ta = a && a.timestamp ? Date.parse(a.timestamp) : 0;
        const tb = b && b.timestamp ? Date.parse(b.timestamp) : 0;
        return ta - tb;
      });
      // process into registro
      registroProcesado = processEventsToRegistro(eventosArr);
      // now build filas (raw events normalized) and render table with no filters initially
      buildAndRenderTable(registroProcesado, readFilters());
      // init filters UI (populates selects)
      initStatsUI();
    }catch(e){
      console.error("Error en renderRegistroEventos:", e);
    }
  });
}

// helper: initial manual refresh
document.getElementById("refreshRegistroBtn").onclick = () => renderRegistroEventos();

// auto call when opening section handled in openSection

</script>

   <script>
  function updateDayHeader() {
  if (!window.currentDayStart) return;

  const timers = window.timers || [];

  const totalObjetivo = timers.reduce((acc, t) => acc + (t.target * 60), 0);
  const totalActual = timers.reduce((acc, t) => acc + t.elapsed, 0);

  // Fecha/hora del inicio
  const startDate = new Date(window.currentDayStart);
  const inicioStr = startDate.toLocaleString();

  // Hora estimada de t√©rmino
  let estimadoStr = "‚Äî";
  if (totalObjetivo > 0) {
    const estimadoFin = new Date(startDate.getTime() + totalObjetivo * 1000);
    estimadoStr = estimadoFin.toLocaleTimeString();
  }

  // Porcentaje de avance
  const progreso = totalObjetivo > 0
    ? ((totalActual / totalObjetivo) * 100).toFixed(1)
    : "0";

  // Escribir datos
  document.getElementById("dayStartLabel").textContent =
    "D√≠a iniciado: " + inicioStr;

  document.getElementById("dayEstimation").textContent =
    "Hora estimada de t√©rmino: " + estimadoStr;

  document.getElementById("dayProgress").textContent =
    "Avance: " + progreso + "%";

  document.getElementById("dayHeader").classList.remove("hidden");
}

</script>

</body>
</html>





















