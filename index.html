
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Proyecto Armando</title>

<style>

  body {
    font-family: 'Segoe UI', sans-serif;
    background: #dbdace;
    color: #a1a1a1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }

  h1 { margin-bottom: 10px; color: #1a1a1a; }

  .controls { margin-bottom: 20px; }

  button {
    background: #3b5dd1;
    border: none;
    color: #f1f1f1;
    padding: 8px 14px;
    margin: 4px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover { background: #5a7be0; }

  #timers-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    width: 90%;
    max-width: 900px;
  }

  .timer {
    background: #1a2f7a;
    border: 1px solid #333;
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .timer.completed {
    background: #164d16;
    border-color: #1d7a1d;
  }

  .timer p span {
    font-size: 2rem;
    font-weight: bold;
    color: #fff;
  }

  .timer h3 { margin: 5px 0; }
  .timer p { margin: 2px 0; }

  .timer .buttons {
    display: flex;
    gap: 6px;
  }

  .draggable { cursor: move; }

  .input-group {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 8px;
  }

  input, textarea {
    padding: 6px;
    border-radius: 5px;
    border: 1px solid #555;
    background: #181818;
    color: #eee;
  }

  textarea { resize: vertical; }

  .hidden { display: none !important; }

  #userSection { margin-bottom: 20px; text-align: center; }

  #loginPanel {
    background: #1c1c1c;
    padding: 20px;
    border-radius: 10px;
    border: 1px solid #333;
    text-align: center;
  }

  #loginPanel input {
    width: 200px;
    margin: 5px 0;
  }

  /* ‚úÖ CAMBIO 1: men√∫ alineado a la derecha */
  #menu {
    position: fixed;
    top: 10px;
    right: 10px;  /* <--- AQUI */
    left: auto;   /* <--- AQUI */
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  #dayInfo {
    margin-bottom: 20px;
    text-align: center;
  }

  /* Estilos tabla de registro */
  #registroTable {
    width: 95%;
    max-width: 1100px;
    border-collapse: collapse;
    margin-top: 12px;
    background: #f7f7f7;
    color: #111;
    border-radius: 8px;
    overflow: hidden;
  }
  #registroTable thead th {
    background: #3b5dd1;
    color: #fff;
    padding: 10px;
    text-align: left;
    font-weight: 600;
  }
  #registroTable tbody td {
    padding: 8px 10px;
    border-bottom: 1px solid #e0e0e0;
    font-size: 0.95rem;
  }
  .small { font-size: 0.9rem; color:#666; }
  #registroControls { margin: 10px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  #registroWrapper { width: 100%; display:flex; flex-direction:column; align-items:center; }

  /* Una fila resaltada para eventos "sin d√≠a" */
  .no-day { background: #fff3cd !important; }

</style>
</head>

<body>

<h1>Proyecto Armando</h1>

<!-- üîµ MENU SUPERIOR -->
<div id="menu">
  <button onclick="openSection('mainPage')">üè† Cron√≥metros</button>
  <button onclick="window.open('estadisticas.html', '_blank')">üìä Estad√≠sticas Generales</button>


  <button onclick="openSection('statsPersonal')">üë§ Estad√≠sticas Individuales</button>
  <!-- NUEVO BOT√ìN -->
  <button onclick="openSection('registroEventos')">üìú Registro de eventos</button>
</div>


<!-- üîµ SECCI√ìN PRINCIPAL -->
<section id="mainPage">

  <div id="dayInfo" class="hidden"></div>

  <!-- LOGIN -->
  <div id="loginPanel">
    <h3>Acceso privado</h3>
    <input type="email" id="emailInput" placeholder="Correo autorizado">
    <input type="password" id="passwordInput" placeholder="Contrase√±a">
    <button id="loginEmailBtn">Ingresar</button>
    <p id="loginError" style="color:#ff5555;"></p>
  </div>

  <!-- Info de usuario -->
  <div id="userSection" class="hidden">
    <p id="userInfo"></p>
    <button id="logoutBtn">Cerrar sesi√≥n</button>
  </div>

  <div class="controls hidden" id="mainControls">
    <button id="startDayBtn">üåÖ Iniciar D√≠a</button>
    <button id="endDayBtn">üåá Finalizar D√≠a</button>
    <button id="addTimerBtn">‚ûï Nuevo Cron√≥metro</button>
  </div>

  <div id="formSection" class="hidden">
    <div class="input-group">
      <input type="text" id="activityName" placeholder="Nombre de la actividad">
      <input type="number" id="targetMinutes" placeholder="Minutos objetivo" min="1">
    </div>

    <div class="input-group">
      <textarea id="note" placeholder="Nota (opcional)"></textarea>
    </div>

    <button id="createTimerBtn">Crear</button>
  </div>

  <div id="timers-container"></div>

</section>


<!-- üîµ ESTAD√çSTICAS GENERALES -->
<section id="statsGeneral" class="hidden">
  <h2>üìä Estad√≠sticas Generales</h2>
  <div id="statsGeneralEmbed"></div>
</section>

<!-- üîµ ESTAD√çSTICAS INDIVIDUALES -->
<section id="statsPersonal" class="hidden">
  <h2>üë§ Estad√≠sticas Individuales</h2>
  <div id="statsPersonalEmbed"></div>
</section>

<!-- üîµ REGISTRO DE EVENTOS -->
<section id="registroEventos" class="hidden">
  <h2>üìú Registro de eventos (historial)</h2>

  <div id="registroWrapper">
    <div id="registroControls">
      <span class="small">Se muestran eventos sincronizados desde Firebase y asignados a d√≠as de trabajo calculados a partir de <b>dia_iniciado</b> / <b>dia_finalizado</b>.</span>
      <button id="refreshRegistroBtn">üîÅ Refrescar ahora</button>
    </div>

    <table id="registroTable">
      <thead>
        <tr>
          <th>D√≠a</th>
          <th>Cron√≥metro</th>
          <th>Acci√≥n</th>
          <th>Marca</th>
          <th>Fecha y hora</th>
          <th>Objetivo (min)</th>
          <th>Creado</th>
        </tr>
      </thead>
      <tbody id="registroBody">
        <!-- filas generadas din√°micamente -->
      </tbody>
    </table>
  </div>
</section>



<!-- üîµ SCRIPT -->
<script type="module">

/* --- FIREBASE (modular v11) --- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getDatabase,
  ref,
  set,
  onValue,
  push,
  get,
  child
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
import {
  getAuth,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyCby9oxzPzBDllkzuW21ZoGNJh67UgYZ8E",
  authDomain: "notion-timers-2a3bb.firebaseapp.com",
  databaseURL: "https://notion-timers-2a3bb-default-rtdb.firebaseio.com",
  projectId: "notion-timers-2a3bb",
  storageBucket: "notion-timers-2a3bb.firebasestorage.app",
  messagingSenderId: "78500747038",
  appId: "1:78500747038:web:2b5fdec3731a203c7f1b0f"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);


/* -------- LOGIN -------- */

document.getElementById("loginEmailBtn").onclick = async () => {
  const email = document.getElementById("emailInput").value;
  const pass = document.getElementById("passwordInput").value;

  try {
    await signInWithEmailAndPassword(auth, email, pass);
  } catch(e){
    document.getElementById("loginError").textContent="Credenciales incorrectas";
    console.error(e);
  }
};

document.getElementById("logoutBtn").onclick = () => signOut(auth);

let dbRef;
let timers = [];
let dayStarted = null;
let dayEnded = null;
let currentUid = null;

// Para asegurar que "timer completado" solo se loguea una vez por timer por sesi√≥n:
const loggedCompletions = new Set();


onAuthStateChanged(auth, user => {
  if(user){
    currentUid = user.uid;

    document.getElementById("loginPanel").classList.add("hidden");
    document.getElementById("userSection").classList.remove("hidden");
    document.getElementById("mainControls").classList.remove("hidden");

    document.getElementById("userInfo").textContent = `Conectado como: ${user.email}`;

    // referencia al diaActual (tu estructura real)
    dbRef = ref(db, `usuarios/${user.uid}/cronometros/diaActual`);
    listen();

    // iniciar escucha del historial de eventos en la secci√≥n registro (se activar√° en renderRegistroEventos)
    // pero podemos preparar el ref
    eventosRefGlobal = ref(db, `usuarios/${user.uid}/historialEventos`);

  } else {

    currentUid = null;
    dbRef = null;

    document.getElementById("loginPanel").classList.remove("hidden");
    document.getElementById("userSection").classList.add("hidden");
    document.getElementById("mainControls").classList.add("hidden");

    timers = [];
    renderTimers();
  }
});


/* -------- CARGA DE DATOS -------- */
function listen() {
  onValue(dbRef, snap => {
    const data = snap.val() || {};
    timers = data.timers || [];
    dayStarted = data.dayStarted || null;
    dayEnded = data.dayEnded || null;
    // Resetear loggedCompletions si cambiaste de d√≠a (evita duplicados en sesi√≥n nueva)
    loggedCompletions.clear();
    renderTimers();
  });
}

async function save() {
  if(!dbRef) return;
  try {
    await set(dbRef,{
      timers,
      dayStarted,
      dayEnded,
      updatedAt:new Date().toISOString()
    });
  } catch(err) {
    console.error("Error guardando diaActual:", err);
  }
}


/* -------- FUNCI√ìN DE LOG DE EVENTOS (historial) -------- */
async function logEvento(uid, tipo, dataExtra = {}) {
  if(!uid) return;
  try {
    const eventosRef = ref(db, `usuarios/${uid}/historialEventos`);
    const evento = {
      timestamp: new Date().toISOString(),
      tipo,
      usuario: uid,
      ...dataExtra
    };
    const newRef = push(eventosRef);
    await set(newRef, evento);
    // no bloqueamos la UI; si quieres usar el resultado, haz await desde el caller
  } catch (e) {
    console.error("Error logeando evento:", e, tipo, dataExtra);
  }
}


/* -------- UTILIDADES -------- */
function formatTimeFromSeconds(s){
  if(s == null || s === undefined) return "";
  s = Number(s);
  if(isNaN(s)) return "";
  const h = String(Math.floor(s/3600)).padStart(2,"0");
  const m = String(Math.floor((s%3600)/60)).padStart(2,"0");
  const s2 = String(s%60).padStart(2,"0");
  return `${h}:${m}:${s2}`;
}

function formatLocal(ts){
  try {
    return new Date(ts).toLocaleString();
  } catch(e){
    return ts;
  }
}

/* -------- NAV SECTIONS -------- */
window.openSection = function(sectionId){
  document.getElementById("mainPage").classList.add("hidden");
  document.getElementById("statsGeneral").classList.add("hidden");
  document.getElementById("statsPersonal").classList.add("hidden");
  document.getElementById("registroEventos").classList.add("hidden");

  document.getElementById(sectionId).classList.remove("hidden");

  if(sectionId === "statsGeneral"){
    import("./estadisticas.js").then(mod => mod.renderStatsGeneral());
  } else if(sectionId === "registroEventos"){
    renderRegistroEventos();
  }
};


/* -------- CREAR CRON√ìMETRO -------- */
document.getElementById("createTimerBtn").onclick = async () => {
  const n = document.getElementById("activityName").value.trim();
  const t = Number(document.getElementById("targetMinutes").value);
  const note = document.getElementById("note").value.trim();

  if(!n || !t) return alert("Nombre y minutos requeridos.");

  // usamos createdAt ISO como timerId √∫nico
  const createdAt = new Date().toISOString();

  const newTimer = {
    name: n,
    target: t,
    note,
    elapsed: 0,
    running: false,
    completed: false,
    createdAt
  };

  timers.push(newTimer);

  document.getElementById("activityName").value="";
  document.getElementById("targetMinutes").value="";
  document.getElementById("note").value="";
  document.getElementById("formSection").classList.add("hidden");

  await save();

  // Log evento: timer creado
  logEvento(currentUid, "timer_creado", {
    timerId: createdAt,
    name: n,
    target: t,
    note
  });

  renderTimers();
};


/* -------- RENDER -------- */
function renderTimers() {
  const container = document.getElementById("timers-container");
  container.innerHTML = "";

  const totalTargetSeconds = timers.reduce((sum, t) => sum + t.target * 60, 0);
  const totalElapsedSeconds = timers.reduce((sum, t) => {
    let display = t.elapsed;
    if (t.running && t.startedAt) display += Math.floor((new Date() - new Date(t.startedAt)) / 1000);
    return sum + display;
  }, 0);

  const dayInfoDiv = document.getElementById("dayInfo");

  if (dayStarted) {
    const start = new Date(dayStarted);
    const estimatedEnd = new Date(start.getTime() + totalTargetSeconds * 1000);
    const progress = totalElapsedSeconds / totalTargetSeconds * 100 || 0;

    dayInfoDiv.innerHTML = `
      <p>D√≠a iniciado: ${start.toLocaleString()}</p>
      <p>Hora estimada de fin: ${estimatedEnd.toLocaleString()}</p>
      <p>Progreso total: ${progress.toFixed(1)}%</p>
    `;
    dayInfoDiv.classList.remove("hidden");
  } else {
    dayInfoDiv.classList.add("hidden");
  }

  timers.forEach((t, i) => {
    const div = document.createElement("div");
    div.className = "timer draggable" + (t.completed ? " completed" : "");
    div.draggable = true;

    // elapsed temporal
    let displayElapsed = t.elapsed;
    if (t.running && t.startedAt) {
      displayElapsed += Math.floor((new Date() - new Date(t.startedAt)) / 1000);
    }

    const pctObj = ((displayElapsed / (t.target * 60)) * 100).toFixed(1);
    const pctTotal = ((displayElapsed / totalTargetSeconds) * 100).toFixed(1);

    div.innerHTML = `
      <h3>${t.name}</h3>
      <p><span>${formatTimeFromSeconds(displayElapsed)}</span></p>
      <p>Objetivo: ${t.target} min</p>
      <p>Progreso espec√≠fico: ${pctObj}%</p>
      <p>Progreso general: ${pctTotal}%</p>
      <p>Creado: ${new Date(t.createdAt).toLocaleString()}</p>
      ${t.note ? `<p><i>${t.note}</i></p>` : ""}
      <div class="buttons">
        <button onclick="toggleTimer(${i})">${t.running?"‚è∏Ô∏è Pausa":"‚ñ∂Ô∏è Iniciar"}</button>
        <button onclick="resetTimer(${i})">üîÑ Reset</button>
        <button onclick="deleteTimer(${i})">üóëÔ∏è Borrar</button>
        <button onclick="editTimer(${i})">‚úèÔ∏è Editar</button>
      </div>
    `;

    container.appendChild(div);
  });

  enableDragAndDrop();
}

setInterval(async () => {
  if (!timers || timers.length === 0) return;
  const now = new Date();
  let needsSave = false;

  timers.forEach(t => {
    if (t.running && t.startedAt) {
      // elapsed real hasta ahora
      const elapsedReal = t.elapsed + Math.floor((now - new Date(t.startedAt)) / 1000);

      // marcar completado si super√≥ objetivo
      if (!t.completed && elapsedReal >= t.target * 60) {
        t.completed = true;
        needsSave = true;

        logEvento(currentUid, "timer_completado", {
          timerId: t.createdAt,
          name: t.name,
          elapsed: elapsedReal
        });
      }
    }
  });

  if (needsSave) await save();

  renderTimers(); // refresca UI cada segundo
}, 1000);


/* ---------- EDITAR ----------- */
window.editTimer = async i => {
  const old = { target: timers[i].target, note: timers[i].note, name: timers[i].name };
  const newTarget = prompt("Nuevo objetivo en minutos:", timers[i].target);
  if (!newTarget || isNaN(newTarget) || newTarget <= 0) return;

  timers[i].target = Number(newTarget);
  timers[i].completed = false;

  await save();

  // Log cambio
  logEvento(currentUid, "timer_editado", {
    timerId: timers[i].createdAt,
    cambios: {
      target: { antes: old.target, despues: timers[i].target }
    }
  });

  renderTimers();
};


/* -------- TIMERS acciones -------- */

window.toggleTimer = async i => {
  if (!dayStarted) return alert("Primero inicia el d√≠a.");
  
  const t = timers[i];
  const timerId = t.createdAt;

  if (!t.running) {
    // === iniciar ===
    t.running = true;
    t.startedAt = new Date().toISOString();   // üî• Se registra el momento exacto del inicio
    await save();

    logEvento(currentUid, "timer_iniciado", {
      timerId,
      name: t.name,
      elapsedAntes: t.elapsed
    });

  } else {
    // === pausar ===
    const nowIso = new Date().toISOString();

    if (t.startedAt) {
      const deltaSec = Math.floor((new Date(nowIso) - new Date(t.startedAt)) / 1000);
      t.elapsed += Math.max(0, deltaSec);     // üî• Se calcula el tiempo REAL
      delete t.startedAt;
    }

    t.running = false;
    await save();

    logEvento(currentUid, "timer_pausado", {
      timerId,
      name: t.name,
      elapsed: t.elapsed
    });
  }

  renderTimers();
};


window.resetTimer = async i => {
  const timerId = timers[i].createdAt;
  const prevElapsed = timers[i].elapsed;
  timers[i].elapsed=0;
  timers[i].running=false;
  timers[i].completed=false;
  await save();

  logEvento(currentUid, "timer_reseteado", {
    timerId,
    prevElapsed
  });

  renderTimers();
};

window.deleteTimer = async i => {
  const timer = timers[i];
  timers.splice(i,1);
  await save();

  logEvento(currentUid, "timer_borrado", {
    timerId: timer.createdAt,
    name: timer.name,
    target: timer.target,
    elapsed: timer.elapsed
  });

  renderTimers();
};


/* -------- TICKER: aumenta elapsed cuando running -------- */

/* -------- TICKER: solo refrescar UI -------- */





/* -------- DRAG & DROP -------- */

let draggedIndex=null;

function enableDragAndDrop(){
  const container = document.getElementById("timers-container");
  const children = container.querySelectorAll(".timer");

  children.forEach(child=>{
    child.ondragstart = e => {
      draggedIndex = [...children].indexOf(e.target);
    };

    child.ondragover = e => e.preventDefault();

    child.ondrop = e => {
      const targetIndex = [...children].indexOf(e.target.closest(".timer"));
      if(targetIndex === -1 || draggedIndex === null) return;

      const moved = timers.splice(draggedIndex,1)[0];
      timers.splice(targetIndex,0,moved);

      draggedIndex=null;
      save();
      renderTimers();
    };
  });
}


/* -------- D√çA -------- */

document.getElementById("startDayBtn").onclick = async () => {
  if(dayStarted) return alert("El d√≠a ya est√° iniciado.");
  dayStarted = new Date().toISOString();
  dayEnded = null;
  await save();

  // log inicio de d√≠a
  logEvento(currentUid, "dia_iniciado", {
    dia: (new Date()).toISOString().slice(0,10),
    dayStarted
  });

  renderTimers();
};

document.getElementById("endDayBtn").onclick = async () => {
  if(!dayStarted) return alert("A√∫n no iniciaste el d√≠a.");
  dayEnded = new Date().toISOString();

  // antes de borrar el estado actual, opcional: guardar snapshot del dia en event
  const snapshot = {
    dayStarted,
    dayEnded,
    timersSnapshot: JSON.parse(JSON.stringify(timers)) // copia
  };

  // reiniciar estado actual
  timers.forEach(t=>{
    t.running=false;
    t.elapsed=0;
    t.completed=false;
  });

  dayStarted = null;

  await save();

  // log finalizacion de dia con snapshot
  logEvento(currentUid, "dia_finalizado", {
    dia: (new Date()).toISOString().slice(0,10),
    ...snapshot
  });

  renderTimers();
};


document.getElementById("addTimerBtn").onclick = () =>
  document.getElementById("formSection").classList.toggle("hidden");


/* =======================
   ===== REGISTRO UI =====
   ======================= */

let eventosRefGlobal = null; // inicializado cuando hay user
let lastEventosListener = null; // para desconectar si es necesario

document.getElementById("refreshRegistroBtn").onclick = () => renderRegistroEventos();

/**
 * renderRegistroEventos:
 * - lee todos los eventos desde usuarios/{uid}/historialEventos
 * - construye intervalos de d√≠as a partir de dia_iniciado/dia_finalizado (en pares)
 * - asigna cada evento a su d√≠a correspondiente comparando timestamps
 * - genera la tabla
 */
async function renderRegistroEventos(){

  if(!currentUid){
    alert("Inicia sesi√≥n para ver el registro de eventos.");
    return;
  }

  // referencia al historial completo
  const eventosRef = ref(db, `usuarios/${currentUid}/historialEventos`);

  // Escucha en tiempo real y re-render cada vez que cambie
  if(lastEventosListener){
    // no hay handle de "off" f√°cil con onValue si no lo guardamos, pero onValue devuelve funci√≥n de cancelaci√≥n: 
    // en modular v11 onValue devuelve funci√≥n de unsubscribe
    lastEventosListener(); // desconecta la escucha anterior
    lastEventosListener = null;
  }

  lastEventosListener = onValue(eventosRef, snap => {
    const raw = snap.val() || {};
    // raw tiene keys pushId: eventoObject
    const eventosArr = Object.entries(raw).map(([key,val]) => ({ id:key, ...val }));
    // ordenar por timestamp asc
    eventosArr.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));

    // construir mapa por timerId de metadatos (creado, objetivo, creadoAt)
    const timersMeta = {}; // timerId -> { name, target, createdAt (timestamp string) }
    eventosArr.forEach(ev => {
      if(ev.tipo === "timer_creado" && ev.timerId){
        // en timer_creado guardaste timerId == createdAt ISO; timestamp del evento es cuando lo cre√≥
        timersMeta[ev.timerId] = {
          name: ev.name || ev.timerId,
          target: ev.target || null,
          createdAt: ev.timestamp // la fecha/hora del evento de creaci√≥n
        };
      }
    });

    // extraer eventos dia_iniciado/dia_finalizado y emparejarlos
    const dias = [];
    const inicios = eventosArr.filter(e => e.tipo === "dia_iniciado");
    const finales = eventosArr.filter(e => e.tipo === "dia_finalizado");

    // Pairing: supones que vienen en orden y siempre pares (salvo un inicio sin final si d√≠a en marcha)
    // Recorremos los inicios y buscamos el siguiente final cuyo timestamp sea posterior
    let usedFinalIndexes = new Set();
    inicios.forEach((inicio, idx) => {
      // buscar primera final cuyo timestamp sea >= inicio.timestamp y que no haya sido usada
      const inicioTs = new Date(inicio.timestamp);
      let matchedFinal = null;
      for(let j=0;j<finales.length;j++){
        if(usedFinalIndexes.has(j)) continue;
        const f = finales[j];
        const fTs = new Date(f.timestamp);
        if(fTs >= inicioTs){
          matchedFinal = { event: f, index: j };
          usedFinalIndexes.add(j);
          break;
        }
      }
      dias.push({
        dia: dias.length + 1, // numeraci√≥n creciente
        inicio: inicio.timestamp,
        fin: matchedFinal ? matchedFinal.event.timestamp : null,
        rawInicioEvent: inicio,
        rawFinEvent: matchedFinal ? matchedFinal.event : null
      });
    });

    // Si hay finales que quedaron sin emparejar (caso raro seg√∫n tu confirmaci√≥n), los ignoramos
    // Construir funci√≥n para asignar un evento a un d√≠a, buscando dentro de 'dias'
    function findDiaForTimestamp(ts){
      const t = new Date(ts);
      for(const d of dias){
        const start = new Date(d.inicio);
        const end = d.fin ? new Date(d.fin) : null;
        if(end){
          if(t >= start && t <= end) return d.dia;
        } else {
          // d√≠a en curso: t >= start
          if(t >= start) return d.dia;
        }
      }
      return null; // sin d√≠a asignado
    }

    // Filtrar solo eventos relacionados con cron√≥metros (o mantener todos pero marcaremos)
    const eventosTimers = eventosArr.filter(e =>
      e.tipo.startsWith("timer_") || e.tipo === "timer_creado" || e.tipo === "timer_editado" || e.tipo === "timer_borrado"
    );

    // Si quieres incluir tambi√©n otros tipos (ej dia_iniciado/dia_finalizado) en la tabla, agrega:
    // const eventosParaTabla = eventosArr; // pero abajo uso eventosTimers

    // Para mostrar en la tabla usaremos eventosArr que contenga tanto timer events como (opcional) dia events.
    const eventosParaTabla = eventosArr; // incluir todo, luego filtramos visualmente

    // Preparamos filas
    const filas = eventosParaTabla.map(ev => {
      // Determinar d√≠a
      const dia = findDiaForTimestamp(ev.timestamp);

      // Intentar obtener timerId y metadata
      const timerId = ev.timerId || (ev.timerId === undefined ? null : ev.timerId);
      const meta = timerId && timersMeta[timerId] ? timersMeta[timerId] : null;

      // Marca/elapsed: distintos nombres en dataExtra: elapsed, elapsedAntes, prevElapsed
      let elapsedSec = null;
      if(ev.elapsed !== undefined && ev.elapsed !== null) elapsedSec = ev.elapsed;
      else if(ev.elapsedAntes !== undefined && ev.elapsedAntes !== null) elapsedSec = ev.elapsedAntes;
      else if(ev.prevElapsed !== undefined && ev.prevElapsed !== null) elapsedSec = ev.prevElapsed;

      // objetivo (en minutos)
      const objetivo = meta ? meta.target : (ev.target || null);

      // nombre cron√≥metro: preferir ev.name (algunos eventos incluyen name), sino meta.name, sino timerId
      const nombre = ev.name || (meta ? meta.name : (timerId || ""));

      return {
        id: ev.id || `${ev.tipo}-${ev.timestamp}`,
        dia,
        tipo: ev.tipo,
        nombre,
        marca: elapsedSec,
        marcaStr: formatTimeFromSeconds(elapsedSec),
        timestamp: ev.timestamp,
        objetivo,
        creado: meta ? meta.createdAt : (ev.createdAt || ""),
        raw: ev
      };
    });

    // ordenar filas por timestamp asc
    filas.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));


/* --- SNIPPET: construir SESSIONS y exponer window.registroProcesado --- */
/* Pegar justo despu√©s de construir `eventosArr`, `dias`, `timersMeta`, `filas` */
// --- Construir objetivos reales seg√∫n eventos ---
const objetivosPorTimer = {};
eventosArr.forEach(ev => {
  if (ev.tipo === "timer_creado" || ev.tipo === "timer_editado") {
    if (ev.timerId && ev.target !== undefined) {
      objetivosPorTimer[ev.timerId] = Number(ev.target);
    }
  }
});

(function createAndExposeRegistroProcesado(){
  // --- util parse marca
  function parseMarca(m){
    if(m === undefined || m === null) return null;
    if(typeof m === 'number') return Number(m);
    const s = String(m).trim();
    if(!s) return null;
    if(s.includes(':')){
      const p = s.split(':').map(x=>Number(x));
      if(p.length===3) return p[0]*3600 + p[1]*60 + p[2];
      if(p.length===2) return p[0]*60 + p[1];
      return null;
    }
    const n = Number(s);
    return isNaN(n) ? null : n;
  }

  // --- construir objetivosPorTimer desde events (soporta varios nombres de campo)
  const objetivosPorTimer = {};
  const nombresPorTimer = {};
  eventosArr.forEach(ev => {
    if(!ev || !ev.tipo) return;
    if(ev.tipo === "timer_creado" || ev.tipo === "timer_editado"){
      const tid = ev.timerId;
      if(!tid) return;
      // posible campos que contienen objetivo
      const cand = ['target','objetivo','targetMin','target_minutes','value','metaTarget','meta','payloadTarget'];
      let found = null;
      for(const k of cand){
        if(ev[k] !== undefined && ev[k] !== null && ev[k] !== "") { found = ev[k]; break; }
      }
      // tambi√©n puede venir dentro de ev.meta o ev.data
      if(found === null && ev.meta && ev.meta.target !== undefined) found = ev.meta.target;
      if(found === null && ev.data && ev.data.target !== undefined) found = ev.data.target;
      if(found !== null) objetivosPorTimer[tid] = Number(found);
      if(ev.name) nombresPorTimer[tid] = ev.name;
    }
  });

  // --- helper para sacar elapsed acumulado de un evento
  function extractElapsedFromEvent(ev){
    if(!ev) return null;
    const keys = ['endElapsed','startElapsed','elapsed','elapsedAntes','marcaElapsed','marca_seconds','marcaSec'];
    for(const k of keys){
      if(ev[k] !== undefined && ev[k] !== null && ev[k] !== '') {
        const n = Number(ev[k]);
        if(!isNaN(n)) return n;
      }
    }
    // si tiene marca textual
    if(ev.marca) {
      const pm = parseMarca(ev.marca);
      if(pm !== null) return pm;
    }
    return null;
  }

  // --- calculo de duracion (misma l√≥gica usada m√°s abajo)
  function calcDuracion(startEv, endEv){
    // 1) marcas HH:MM:SS preferidas
    const m1 = parseMarca(startEv && (startEv.marca || startEv.marcaStr || startEv.marca_str));
    const m2 = parseMarca(endEv && (endEv.marca || endEv.marcaStr || endEv.marca_str));
    if(m1 !== null && m2 !== null && m2 >= m1) return Math.max(0, Math.floor(m2 - m1));

    // 2) elapsed acumulado
    const sEl = startEv && (startEv.startElapsed ?? startEv.elapsedAntes ?? startEv.elapsed ?? null);
    const eEl = endEv && (endEv.endElapsed ?? endEv.elapsed ?? endEv.elapsedAntes ?? null);
    if(sEl !== null && eEl !== null && !isNaN(sEl) && !isNaN(eEl) && eEl >= sEl) return Math.max(0, Math.floor(Number(eEl) - Number(sEl)));

    // 3) fallback timestamps
    try {
      const st = startEv && (typeof startEv.timestamp === 'number' ? startEv.timestamp : Date.parse(startEv.timestamp));
      const en = endEv && (typeof endEv.timestamp === 'number' ? endEv.timestamp : Date.parse(endEv.timestamp));
      if(!isNaN(st) && !isNaN(en) && en >= st) return Math.max(0, Math.floor((en - st) / 1000));
    } catch(e){}
    return 0;
  }

  // --- construir sesiones con lookahead para evitar cierres "duplicados" (timer_completado vs timer_pausado)
  const sessions = [];
  const openMap = {}; // timerId -> startEv

  // convertimos a for-index para poder mirar adelante
  for(let i=0;i<eventosArr.length;i++){
    const ev = eventosArr[i];
    const tipo = ev && ev.tipo;
    const tid = ev && ev.timerId ? ev.timerId : null;

    // abrir
    if(tipo === 'timer_iniciado' && tid){
      // si ya hay un open, lo sobreescribimos (pero podr√≠amos cerrarlo autom√°ticamente si queremos)
      openMap[tid] = ev;
      continue;
    }

    // si es evento de cierre potencial
    const cierres = ['timer_pausado','timer_reseteado','timer_completado','timer_borrado'];
    if(tid && cierres.includes(tipo)){
      const startEv = openMap[tid];
      if(!startEv){
        // no hay inicio abierto: ignorar
        continue;
      }

      // lookahead: buscar events posteriores (hasta X indices o hasta pr√≥ximo timer_iniciado para este tid)
      let bestEndEv = ev;
      let bestScore = -Infinity; // prefer larger elapsed or later timestamp
      // compute score for a given endEv
      const scoreOf = (endEv) => {
        const eEl = extractElapsedFromEvent(endEv);
        const ts = (typeof endEv.timestamp === 'number') ? endEv.timestamp : Date.parse(endEv.timestamp);
        let score = 0;
        if(eEl !== null && !isNaN(eEl)) score += eEl * 1000; // heavy weight
        if(!isNaN(ts)) score += Math.floor(ts/1000);
        // prefer tipos: pausado > completado > reset > borrado
        const pref = { 'timer_pausado':4, 'timer_completado':3, 'timer_reseteado':2, 'timer_borrado':1 };
        score += (pref[endEv.tipo] || 0);
        return score;
      };

      // start scanning ahead (look max 8 events or until next timer_iniciado for same tid)
      for(let j=i; j<Math.min(eventosArr.length, i+12); j++){
        const candidate = eventosArr[j];
        if(!candidate) continue;
        if(candidate.timerId !== tid) continue;
        if(candidate.tipo === 'timer_iniciado') break; // nuevo inicio cancela b√∫squeda
        if(!cierres.includes(candidate.tipo)) continue;

        const sc = scoreOf(candidate);
        if(sc > bestScore){
          bestScore = sc;
          bestEndEv = candidate;
        }
      }

      // compute duration using startEv & bestEndEv
      const durationSec = calcDuracion(startEv, bestEndEv);

      // determine dia using startEv.timestamp and dias array
      let diaNum = null;
      const st = new Date(startEv.timestamp);
      for(const d of dias){
        const s = new Date(d.inicio);
        const e = d.fin ? new Date(d.fin) : null;
        if(e){
          if(st >= s && st <= e){ diaNum = d.dia; break; }
        } else {
          if(st >= s){ diaNum = d.dia; break; }
        }
      }
      const dateKey = startEv && startEv.timestamp ? (new Date(startEv.timestamp)).toISOString().slice(0,10) : null;

      // nombre preferido
      const name = startEv.name || nombresPorTimer[tid] || (timersMeta && timersMeta[tid] && timersMeta[tid].name) || null;

      // objetivo - prioridad: objetivosPorTimer -> timersMeta -> startEv.target -> null
      const objetivoMin = (objetivosPorTimer[tid] !== undefined && objetivosPorTimer[tid] !== null)
                            ? Number(objetivosPorTimer[tid])
                            : (timersMeta && timersMeta[tid] && (timersMeta[tid].target !== undefined)
                                ? Number(timersMeta[tid].target)
                                : (startEv && (startEv.target !== undefined) ? Number(startEv.target) : null)
                              );

      sessions.push({
        timerId: tid,
        name,
        startTs: startEv.timestamp,
        endTs: bestEndEv.timestamp || null,
        startElapsed: (startEv.startElapsed ?? startEv.elapsedAntes ?? startEv.elapsed ?? null),
        endElapsed: (bestEndEv.endElapsed ?? bestEndEv.elapsed ?? bestEndEv.elapsedAntes ?? null),
        durationSec,
        dia: diaNum,
        dateKey,
        objetivoMin: (objetivoMin !== undefined ? (isNaN(Number(objetivoMin)) ? null : Number(objetivoMin)) : null),
        closingType: bestEndEv.tipo || tipo
      });

      // eliminar openMap entry
      delete openMap[tid];

      // advance i to the index of bestEndEv to avoid creating extra sessions for intermediate "completado" markers
      // find index of bestEndEv
      let idxBest = i;
      for(let k=i; k<eventosArr.length && k<=i+12; k++){
        if(eventosArr[k] === bestEndEv){ idxBest = k; break; }
      }
      i = idxBest; // the for loop will increment i further in next iteration
    }
  } // end for eventosArr

  // cerrar sesiones abiertas usando day.fin si existe o now (misma l√≥gica, usando calcDuracion)
  const nowIso = new Date().toISOString();
  Object.keys(openMap).forEach(timerId => {
    const openObj = openMap[timerId];
    const startEv = openObj;
    // intentar cerrar en el fin del d√≠a si existe el d√≠a correspondiente
    let closed = false;
    for(const d of dias){
      const s = new Date(d.inicio);
      const e = d.fin ? new Date(d.fin) : null;
      const st = new Date(startEv.timestamp);
      if(e && st >= s && st <= e){
        const fakeEndEv = { timestamp: d.fin, tipo: "auto_cierre_por_day_end" };
        const durationSec = calcDuracion(startEv, fakeEndEv);
        const dateKey = (new Date(startEv.timestamp)).toISOString().slice(0,10);
        sessions.push({
          timerId,
          name: startEv.name || nombresPorTimer[timerId] || (timersMeta && timersMeta[timerId] && timersMeta[timerId].name) || null,
          startTs: startEv.timestamp,
          endTs: d.fin,
          startElapsed: (startEv.startElapsed ?? startEv.elapsedAntes ?? startEv.elapsed ?? null),
          endElapsed: null,
          durationSec,
          dia: d.dia,
          dateKey,
          objetivoMin: (objetivosPorTimer[timerId] !== undefined) ? Number(objetivosPorTimer[timerId]) : ((timersMeta && timersMeta[timerId] && timersMeta[timerId].target !== undefined) ? Number(timersMeta[timerId].target) : null),
          closingType: "auto_cierre_por_day_end"
        });
        closed = true;
        break;
      }
    }
    if(!closed){
      const fakeEndEv = { timestamp: nowIso, tipo: "auto_cierre_por_now" };
      const durationSec = calcDuracion(startEv, fakeEndEv);
      const dateKey = (new Date(startEv.timestamp)).toISOString().slice(0,10);
      sessions.push({
        timerId,
        name: startEv.name || nombresPorTimer[timerId] || (timersMeta && timersMeta[timerId] && timersMeta[timerId].name) || null,
        startTs: startEv.timestamp,
        endTs: nowIso,
        startElapsed: (startEv.startElapsed ?? startEv.elapsedAntes ?? startEv.elapsed ?? null),
        endElapsed: null,
        durationSec,
        dia: null,
        dateKey,
        objetivoMin: (objetivosPorTimer[timerId] !== undefined) ? Number(objetivosPorTimer[timerId]) : ((timersMeta && timersMeta[timerId] && timersMeta[timerId].target !== undefined) ? Number(timersMeta[timerId].target) : null),
        closingType: "auto_cierre_por_now"
      });
    }
  });

  // timersMeta ya la tienes (construida antes). Queremos exponer tambien timersMeta completo basado en objetivosPorTimer
  const finalTimersMeta = Object.assign({}, timersMeta || {});
  // copiar objetivos detectados por eventos
  Object.keys(objetivosPorTimer).forEach(k => {
    finalTimersMeta[k] = Object.assign({}, finalTimersMeta[k] || {}, { name: finalTimersMeta[k] && finalTimersMeta[k].name ? finalTimersMeta[k].name : (nombresPorTimer[k] || (finalTimersMeta[k] && finalTimersMeta[k].name) || null), target: Number(objetivosPorTimer[k]) });
  });

  window.registroProcesado = {
    dias: dias.map(d => ({ dia: d.dia, inicio: d.inicio, fin: d.fin || null })),
    sessions: sessions,
    timersMeta: finalTimersMeta
  };

  // notificar a quien escuche
  window.dispatchEvent(new CustomEvent('registroProcesadoReady', { detail: window.registroProcesado }));

})();



    
    // RENDER TABLA
    const tbody = document.getElementById("registroBody");
    tbody.innerHTML = "";

    filas.forEach(f => {
      const tr = document.createElement("tr");
      if(f.dia === null) tr.classList.add("no-day");

      tr.innerHTML = `
        <td>${f.dia === null ? "<i>sin d√≠a asignado</i>" : f.dia}</td>
        <td>${escapeHtml(f.nombre || "")}</td>
        <td>${escapeHtml(f.tipo)}</td>
        <td>${f.marcaStr || ""}</td>
        <td>${formatLocal(f.timestamp)}</td>
        <td>${f.objetivo === null || f.objetivo === undefined ? "" : f.objetivo}</td>
        <td>${f.creado ? formatLocal(f.creado) : ""}</td>
      `;
      tbody.appendChild(tr);
    });

    // Si no hay d√≠as detectados, mostrar nota
    if(dias.length === 0){
      // opci√≥n: mostrar alerta o mensaje en la UI (aqu√≠ agregamos una fila)
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="7" class="small">No se detectaron pares dia_iniciado / dia_finalizado. Si existe un d√≠a en curso, aparecer√° como 'en curso' (fin vac√≠o).</td>`;
      tbody.prepend(tr);
    }

  }); // onValue
} // renderRegistroEventos

// utilidad m√≠nima para escapar HTML en nombres/strings
function escapeHtml(unsafe) {
  if(!unsafe && unsafe !== 0) return "";
  return String(unsafe)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'", "&#039;");
}
document.getElementById("btnEstadisticas").onclick = () => {
    if (!window.registroProcesado) {
        alert("Todav√≠a no se gener√≥ el registro de eventos.");
        return;
    }


    localStorage.setItem("registroProcesado", JSON.stringify(window.registroProcesado));
localStorage.setItem("registroFilas", JSON.stringify(filas));
    window.open("estadisticas.html", "_blank");
};
/* ===========================
   ====== FIN registro UI =====
   =========================== */

</script>

 
<!-- Conexi√≥n al archivo externo de estad√≠sticas -->


</body>
</html>






















































































