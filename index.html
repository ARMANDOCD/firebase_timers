<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Proyecto Armando</title>

<style>

  body {
    font-family: 'Segoe UI', sans-serif;
    background: #dbdace;
    color: #a1a1a1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }

  h1 { margin-bottom: 10px; color: #1a1a1a; }

  .controls { margin-bottom: 20px; }

  button {
    background: #3b5dd1;
    border: none;
    color: #f1f1f1;
    padding: 8px 14px;
    margin: 4px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover { background: #5a7be0; }

  #timers-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 15px;
    width: 90%;
    max-width: 900px;
  }

  .timer {
    background: #1a2f7a;
    border: 1px solid #333;
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .timer.completed {
    background: #164d16;
    border-color: #1d7a1d;
  }

  .timer p span {
    font-size: 2rem;
    font-weight: bold;
    color: #fff;
  }

  .timer h3 { margin: 5px 0; }
  .timer p { margin: 2px 0; }

  .timer .buttons {
    display: flex;
    gap: 6px;
  }

  .draggable { cursor: move; }

  .input-group {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 8px;
  }

  input, textarea {
    padding: 6px;
    border-radius: 5px;
    border: 1px solid #555;
    background: #181818;
    color: #eee;
  }

  textarea { resize: vertical; }

  .hidden { display: none !important; }

  #userSection { margin-bottom: 20px; text-align: center; }

  #loginPanel {
    background: #1c1c1c;
    padding: 20px;
    border-radius: 10px;
    border: 1px solid #333;
    text-align: center;
  }

  #loginPanel input {
    width: 200px;
    margin: 5px 0;
  }

  /* ‚úÖ CAMBIO 1: men√∫ alineado a la derecha */
  #menu {
    position: fixed;
    top: 10px;
    right: 10px;  /* <--- AQUI */
    left: auto;   /* <--- AQUI */
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  #dayInfo {
    margin-bottom: 20px;
    text-align: center;
  }

  /* Estilos tabla de registro */
  #registroTable {
    width: 95%;
    max-width: 1100px;
    border-collapse: collapse;
    margin-top: 12px;
    background: #f7f7f7;
    color: #111;
    border-radius: 8px;
    overflow: hidden;
  }
  #registroTable thead th {
    background: #3b5dd1;
    color: #fff;
    padding: 10px;
    text-align: left;
    font-weight: 600;
  }
  #registroTable tbody td {
    padding: 8px 10px;
    border-bottom: 1px solid #e0e0e0;
    font-size: 0.95rem;
  }
  .small { font-size: 0.9rem; color:#666; }
  #registroControls { margin: 10px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  #registroWrapper { width: 100%; display:flex; flex-direction:column; align-items:center; }

  /* Una fila resaltada para eventos "sin d√≠a" */
  .no-day { background: #fff3cd !important; }

</style>
</head>

<body>

<h1>Proyecto Armando</h1>

<!-- üîµ MENU SUPERIOR -->
<div id="menu">
  <button onclick="openSection('mainPage')">üè† Cron√≥metros</button>
  <button onclick="openSection('statsGeneral')">üìä Estad√≠sticas Generales</button>
  <button onclick="openSection('statsPersonal')">üë§ Estad√≠sticas Individuales</button>
  <!-- NUEVO BOT√ìN -->
  <button onclick="openSection('registroEventos')">üìú Registro de eventos</button>
</div>


<!-- üîµ SECCI√ìN PRINCIPAL -->
<section id="mainPage">

  <div id="dayInfo" class="hidden"></div>

  <!-- LOGIN -->
  <div id="loginPanel">
    <h3>Acceso privado</h3>
    <input type="email" id="emailInput" placeholder="Correo autorizado">
    <input type="password" id="passwordInput" placeholder="Contrase√±a">
    <button id="loginEmailBtn">Ingresar</button>
    <p id="loginError" style="color:#ff5555;"></p>
  </div>

  <!-- Info de usuario -->
  <div id="userSection" class="hidden">
    <p id="userInfo"></p>
    <button id="logoutBtn">Cerrar sesi√≥n</button>
  </div>

  <div class="controls hidden" id="mainControls">
    <button id="startDayBtn">üåÖ Iniciar D√≠a</button>
    <button id="endDayBtn">üåá Finalizar D√≠a</button>
    <button id="addTimerBtn">‚ûï Nuevo Cron√≥metro</button>
  </div>

  <div id="formSection" class="hidden">
    <div class="input-group">
      <input type="text" id="activityName" placeholder="Nombre de la actividad">
      <input type="number" id="targetMinutes" placeholder="Minutos objetivo" min="1">
    </div>

    <div class="input-group">
      <textarea id="note" placeholder="Nota (opcional)"></textarea>
    </div>

    <button id="createTimerBtn">Crear</button>
  </div>

  <div id="timers-container"></div>

</section>


<!-- üîµ ESTAD√çSTICAS GENERALES -->
<section id="statsGeneral" class="hidden">
  <h2>üìä Estad√≠sticas Generales</h2>
  <div id="statsGeneralEmbed"></div>
</section>

<!-- üîµ ESTAD√çSTICAS INDIVIDUALES -->
<section id="statsPersonal" class="hidden">
  <h2>üë§ Estad√≠sticas Individuales</h2>
  <div id="statsPersonalEmbed"></div>
</section>

<!-- üîµ REGISTRO DE EVENTOS -->
<section id="registroEventos" class="hidden">
  <h2>üìú Registro de eventos (historial)</h2>

  <div id="registroWrapper">
    <div id="registroControls">
      <span class="small">Se muestran eventos sincronizados desde Firebase y asignados a d√≠as de trabajo calculados a partir de <b>dia_iniciado</b> / <b>dia_finalizado</b>.</span>
      <button id="refreshRegistroBtn">üîÅ Refrescar ahora</button>
    </div>

    <table id="registroTable">
      <thead>
        <tr>
          <th>D√≠a</th>
          <th>Cron√≥metro</th>
          <th>Acci√≥n</th>
          <th>Marca</th>
          <th>Fecha y hora</th>
          <th>Objetivo (min)</th>
          <th>Creado</th>
        </tr>
      </thead>
      <tbody id="registroBody">
        <!-- filas generadas din√°micamente -->
      </tbody>
    </table>
  </div>
</section>



<!-- üîµ SCRIPT -->
<script type="module">

/* --- FIREBASE (modular v11) --- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getDatabase,
  ref,
  set,
  onValue,
  push,
  get,
  child
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
import {
  getAuth,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyCby9oxzPzBDllkzuW21ZoGNJh67UgYZ8E",
  authDomain: "notion-timers-2a3bb.firebaseapp.com",
  databaseURL: "https://notion-timers-2a3bb-default-rtdb.firebaseio.com",
  projectId: "notion-timers-2a3bb",
  storageBucket: "notion-timers-2a3bb.firebasestorage.app",
  messagingSenderId: "78500747038",
  appId: "1:78500747038:web:2b5fdec3731a203c7f1b0f"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);


/* -------- LOGIN -------- */

document.getElementById("loginEmailBtn").onclick = async () => {
  const email = document.getElementById("emailInput").value;
  const pass = document.getElementById("passwordInput").value;

  try {
    await signInWithEmailAndPassword(auth, email, pass);
  } catch(e){
    document.getElementById("loginError").textContent="Credenciales incorrectas";
    console.error(e);
  }
};

document.getElementById("logoutBtn").onclick = () => signOut(auth);

let dbRef;
let timers = [];
let dayStarted = null;
let dayEnded = null;
let currentUid = null;

// Para asegurar que "timer completado" solo se loguea una vez por timer por sesi√≥n:
const loggedCompletions = new Set();


onAuthStateChanged(auth, user => {
  if(user){
    currentUid = user.uid;

    document.getElementById("loginPanel").classList.add("hidden");
    document.getElementById("userSection").classList.remove("hidden");
    document.getElementById("mainControls").classList.remove("hidden");

    document.getElementById("userInfo").textContent = `Conectado como: ${user.email}`;

    // referencia al diaActual (tu estructura real)
    dbRef = ref(db, `usuarios/${user.uid}/cronometros/diaActual`);
    listen();

    // iniciar escucha del historial de eventos en la secci√≥n registro (se activar√° en renderRegistroEventos)
    // pero podemos preparar el ref
    eventosRefGlobal = ref(db, `usuarios/${user.uid}/historialEventos`);

  } else {

    currentUid = null;
    dbRef = null;

    document.getElementById("loginPanel").classList.remove("hidden");
    document.getElementById("userSection").classList.add("hidden");
    document.getElementById("mainControls").classList.add("hidden");

    timers = [];
    renderTimers();
  }
});


/* -------- CARGA DE DATOS -------- */
function listen() {
  onValue(dbRef, snap => {
    const data = snap.val() || {};
    timers = data.timers || [];
    dayStarted = data.dayStarted || null;
    dayEnded = data.dayEnded || null;
    // Resetear loggedCompletions si cambiaste de d√≠a (evita duplicados en sesi√≥n nueva)
    loggedCompletions.clear();
    renderTimers();
  });
}

async function save() {
  if(!dbRef) return;
  try {
    await set(dbRef,{
      timers,
      dayStarted,
      dayEnded,
      updatedAt:new Date().toISOString()
    });
  } catch(err) {
    console.error("Error guardando diaActual:", err);
  }
}


/* -------- FUNCI√ìN DE LOG DE EVENTOS (historial) -------- */
async function logEvento(uid, tipo, dataExtra = {}) {
  if(!uid) return;
  try {
    const eventosRef = ref(db, `usuarios/${uid}/historialEventos`);
    const evento = {
      timestamp: new Date().toISOString(),
      tipo,
      usuario: uid,
      ...dataExtra
    };
    const newRef = push(eventosRef);
    await set(newRef, evento);
    // no bloqueamos la UI; si quieres usar el resultado, haz await desde el caller
  } catch (e) {
    console.error("Error logeando evento:", e, tipo, dataExtra);
  }
}


/* -------- UTILIDADES -------- */
function formatTimeFromSeconds(s){
  if(s == null || s === undefined) return "";
  s = Number(s);
  if(isNaN(s)) return "";
  const h = String(Math.floor(s/3600)).padStart(2,"0");
  const m = String(Math.floor((s%3600)/60)).padStart(2,"0");
  const s2 = String(s%60).padStart(2,"0");
  return `${h}:${m}:${s2}`;
}

function formatLocal(ts){
  try {
    return new Date(ts).toLocaleString();
  } catch(e){
    return ts;
  }
}

/* -------- NAV SECTIONS -------- */
window.openSection = function(sectionId){
  document.getElementById("mainPage").classList.add("hidden");
  document.getElementById("statsGeneral").classList.add("hidden");
  document.getElementById("statsPersonal").classList.add("hidden");
  document.getElementById("registroEventos").classList.add("hidden");

  document.getElementById(sectionId).classList.remove("hidden");

  if(sectionId === "statsGeneral"){
    import("./estadisticas.js").then(mod => mod.renderStatsGeneral());
  } else if(sectionId === "registroEventos"){
    renderRegistroEventos();
  }
};


/* -------- CREAR CRON√ìMETRO -------- */
document.getElementById("createTimerBtn").onclick = async () => {
  const n = document.getElementById("activityName").value.trim();
  const t = Number(document.getElementById("targetMinutes").value);
  const note = document.getElementById("note").value.trim();

  if(!n || !t) return alert("Nombre y minutos requeridos.");

  // usamos createdAt ISO como timerId √∫nico
  const createdAt = new Date().toISOString();

  const newTimer = {
    name: n,
    target: t,
    note,
    elapsed: 0,
    running: false,
    completed: false,
    createdAt
  };

  timers.push(newTimer);

  document.getElementById("activityName").value="";
  document.getElementById("targetMinutes").value="";
  document.getElementById("note").value="";
  document.getElementById("formSection").classList.add("hidden");

  await save();

  // Log evento: timer creado
  logEvento(currentUid, "timer_creado", {
    timerId: createdAt,
    name: n,
    target: t,
    note
  });

  renderTimers();
};


/* -------- RENDER -------- */
function renderTimers(){

  const container = document.getElementById("timers-container");
  container.innerHTML="";

  const totalTargetSeconds = timers.reduce((sum,t)=>sum+t.target*60,0);
  const totalElapsedSeconds = timers.reduce((sum,t)=>sum+t.elapsed,0);

  const dayInfoDiv = document.getElementById("dayInfo");

  if(dayStarted){

    const start = new Date(dayStarted);
    const estimatedEnd = new Date(start.getTime() + totalTargetSeconds*1000);
    const progress = totalElapsedSeconds / totalTargetSeconds * 100 || 0;

    dayInfoDiv.innerHTML = `
      <p>D√≠a iniciado: ${start.toLocaleString()}</p>
      <p>Hora estimada de fin: ${estimatedEnd.toLocaleString()}</p>
      <p>Progreso total: ${progress.toFixed(1)}%</p>
    `;

    dayInfoDiv.classList.remove("hidden");

  } else {
    dayInfoDiv.classList.add("hidden");
  }



  timers.forEach((t,i)=>{

    const div = document.createElement("div");
    div.className = "timer draggable" + (t.completed ? " completed" : "");
    div.draggable = true;

    const pctObj = (t.elapsed/(t.target*60)*100).toFixed(1);
    const pctTotal = (t.elapsed/totalTargetSeconds*100).toFixed(1);
let displayElapsed = t.elapsed;
if (t.running && t.startedAt) {
  displayElapsed += Math.floor(
    (new Date() - new Date(t.startedAt)) / 1000
  );
}
    div.innerHTML = `
      <h3>${t.name}</h3>
      <p><span>${formatTimeFromSeconds(displayElapsed)}</span></p>

      <p>Objetivo: ${t.target} min</p>
      <p>Progreso espec√≠fico: ${pctObj}%</p>
      <p>Progreso general: ${pctTotal}%</p>
      <p>Creado: ${new Date(t.createdAt).toLocaleString()}</p>
      ${t.note ? `<p><i>${t.note}</i></p>` : ""}
      <div class="buttons">
        <button onclick="toggleTimer(${i})">${t.running?"‚è∏Ô∏è Pausa":"‚ñ∂Ô∏è Iniciar"}</button>
        <button onclick="resetTimer(${i})">üîÑ Reset</button>
        <button onclick="deleteTimer(${i})">üóëÔ∏è Borrar</button>
        <button onclick="editTimer(${i})">‚úèÔ∏è Editar</button>
      </div>
    `;

    container.appendChild(div);
  });

  enableDragAndDrop();
}

setInterval(() => {
  renderTimers();
}, 1000);

/* ---------- EDITAR ----------- */
window.editTimer = async i => {
  const old = { target: timers[i].target, note: timers[i].note, name: timers[i].name };
  const newTarget = prompt("Nuevo objetivo en minutos:", timers[i].target);
  if (!newTarget || isNaN(newTarget) || newTarget <= 0) return;

  timers[i].target = Number(newTarget);
  timers[i].completed = false;

  await save();

  // Log cambio
  logEvento(currentUid, "timer_editado", {
    timerId: timers[i].createdAt,
    cambios: {
      target: { antes: old.target, despues: timers[i].target }
    }
  });

  renderTimers();
};


/* -------- TIMERS acciones -------- */

window.toggleTimer = async i => {
  if (!dayStarted) return alert("Primero inicia el d√≠a.");
  
  const t = timers[i];
  const timerId = t.createdAt;

  if (!t.running) {
    // === iniciar ===
    t.running = true;
    t.startedAt = new Date().toISOString();   // üî• Se registra el momento exacto del inicio
    await save();

    logEvento(currentUid, "timer_iniciado", {
      timerId,
      name: t.name,
      elapsedAntes: t.elapsed
    });

  } else {
    // === pausar ===
    const nowIso = new Date().toISOString();

    if (t.startedAt) {
      const deltaSec = Math.floor((new Date(nowIso) - new Date(t.startedAt)) / 1000);
      t.elapsed += Math.max(0, deltaSec);     // üî• Se calcula el tiempo REAL
      delete t.startedAt;
    }

    t.running = false;
    await save();

    logEvento(currentUid, "timer_pausado", {
      timerId,
      name: t.name,
      elapsed: t.elapsed
    });
  }

  renderTimers();
};


window.resetTimer = async i => {
  const timerId = timers[i].createdAt;
  const prevElapsed = timers[i].elapsed;
  timers[i].elapsed=0;
  timers[i].running=false;
  timers[i].completed=false;
  await save();

  logEvento(currentUid, "timer_reseteado", {
    timerId,
    prevElapsed
  });

  renderTimers();
};

window.deleteTimer = async i => {
  const timer = timers[i];
  timers.splice(i,1);
  await save();

  logEvento(currentUid, "timer_borrado", {
    timerId: timer.createdAt,
    name: timer.name,
    target: timer.target,
    elapsed: timer.elapsed
  });

  renderTimers();
};


/* -------- TICKER: aumenta elapsed cuando running -------- */

/* -------- TICKER: solo refrescar UI -------- */
setInterval(()=>{
  let changed=false;
  timers.forEach(t=>{
    if(t.running){
      t.elapsed++; // ‚¨ÖÔ∏è incrementa tiempo transcurrido
      // marcar completado si alcanza objetivo
      if(t.elapsed >= t.target*60 && !t.completed){
        t.completed = true;
        const id = t.createdAt;
        if(!loggedCompletions.has(id)){
          loggedCompletions.add(id);
          logEvento(currentUid, "timer_completado", {
            timerId: id,
            name: t.name,
            elapsed: t.elapsed,
            target: t.target
          });
        }
      }
      changed=true;
    }
  });
  if(changed) renderTimers(); // ‚¨ÖÔ∏è ‚¨ÖÔ∏è ‚¨ÖÔ∏è esto vuelve a dibujar los timers cada segundo
},1000);




/* -------- DRAG & DROP -------- */

let draggedIndex=null;

function enableDragAndDrop(){
  const container = document.getElementById("timers-container");
  const children = container.querySelectorAll(".timer");

  children.forEach(child=>{
    child.ondragstart = e => {
      draggedIndex = [...children].indexOf(e.target);
    };

    child.ondragover = e => e.preventDefault();

    child.ondrop = e => {
      const targetIndex = [...children].indexOf(e.target.closest(".timer"));
      if(targetIndex === -1 || draggedIndex === null) return;

      const moved = timers.splice(draggedIndex,1)[0];
      timers.splice(targetIndex,0,moved);

      draggedIndex=null;
      save();
      renderTimers();
    };
  });
}


/* -------- D√çA -------- */

document.getElementById("startDayBtn").onclick = async () => {
  if(dayStarted) return alert("El d√≠a ya est√° iniciado.");
  dayStarted = new Date().toISOString();
  dayEnded = null;
  await save();

  // log inicio de d√≠a
  logEvento(currentUid, "dia_iniciado", {
    dia: (new Date()).toISOString().slice(0,10),
    dayStarted
  });

  renderTimers();
};

document.getElementById("endDayBtn").onclick = async () => {
  if(!dayStarted) return alert("A√∫n no iniciaste el d√≠a.");
  dayEnded = new Date().toISOString();

  // antes de borrar el estado actual, opcional: guardar snapshot del dia en event
  const snapshot = {
    dayStarted,
    dayEnded,
    timersSnapshot: JSON.parse(JSON.stringify(timers)) // copia
  };

  // reiniciar estado actual
  timers.forEach(t=>{
    t.running=false;
    t.elapsed=0;
    t.completed=false;
  });

  dayStarted = null;

  await save();

  // log finalizacion de dia con snapshot
  logEvento(currentUid, "dia_finalizado", {
    dia: (new Date()).toISOString().slice(0,10),
    ...snapshot
  });

  renderTimers();
};


document.getElementById("addTimerBtn").onclick = () =>
  document.getElementById("formSection").classList.toggle("hidden");


/* =======================
   ===== REGISTRO UI =====
   ======================= */

let eventosRefGlobal = null; // inicializado cuando hay user
let lastEventosListener = null; // para desconectar si es necesario

document.getElementById("refreshRegistroBtn").onclick = () => renderRegistroEventos();

/**
 * renderRegistroEventos:
 * - lee todos los eventos desde usuarios/{uid}/historialEventos
 * - construye intervalos de d√≠as a partir de dia_iniciado/dia_finalizado (en pares)
 * - asigna cada evento a su d√≠a correspondiente comparando timestamps
 * - genera la tabla
 */
async function renderRegistroEventos(){

  if(!currentUid){
    alert("Inicia sesi√≥n para ver el registro de eventos.");
    return;
  }

  // referencia al historial completo
  const eventosRef = ref(db, `usuarios/${currentUid}/historialEventos`);

  // Escucha en tiempo real y re-render cada vez que cambie
  if(lastEventosListener){
    // no hay handle de "off" f√°cil con onValue si no lo guardamos, pero onValue devuelve funci√≥n de cancelaci√≥n: 
    // en modular v11 onValue devuelve funci√≥n de unsubscribe
    lastEventosListener(); // desconecta la escucha anterior
    lastEventosListener = null;
  }

  lastEventosListener = onValue(eventosRef, snap => {
    const raw = snap.val() || {};
    // raw tiene keys pushId: eventoObject
    const eventosArr = Object.entries(raw).map(([key,val]) => ({ id:key, ...val }));
    // ordenar por timestamp asc
    eventosArr.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));

    // construir mapa por timerId de metadatos (creado, objetivo, creadoAt)
    const timersMeta = {}; // timerId -> { name, target, createdAt (timestamp string) }
    eventosArr.forEach(ev => {
      if(ev.tipo === "timer_creado" && ev.timerId){
        // en timer_creado guardaste timerId == createdAt ISO; timestamp del evento es cuando lo cre√≥
        timersMeta[ev.timerId] = {
          name: ev.name || ev.timerId,
          target: ev.target || null,
          createdAt: ev.timestamp // la fecha/hora del evento de creaci√≥n
        };
      }
    });

    // extraer eventos dia_iniciado/dia_finalizado y emparejarlos
    const dias = [];
    const inicios = eventosArr.filter(e => e.tipo === "dia_iniciado");
    const finales = eventosArr.filter(e => e.tipo === "dia_finalizado");

    // Pairing: supones que vienen en orden y siempre pares (salvo un inicio sin final si d√≠a en marcha)
    // Recorremos los inicios y buscamos el siguiente final cuyo timestamp sea posterior
    let usedFinalIndexes = new Set();
    inicios.forEach((inicio, idx) => {
      // buscar primera final cuyo timestamp sea >= inicio.timestamp y que no haya sido usada
      const inicioTs = new Date(inicio.timestamp);
      let matchedFinal = null;
      for(let j=0;j<finales.length;j++){
        if(usedFinalIndexes.has(j)) continue;
        const f = finales[j];
        const fTs = new Date(f.timestamp);
        if(fTs >= inicioTs){
          matchedFinal = { event: f, index: j };
          usedFinalIndexes.add(j);
          break;
        }
      }
      dias.push({
        dia: dias.length + 1, // numeraci√≥n creciente
        inicio: inicio.timestamp,
        fin: matchedFinal ? matchedFinal.event.timestamp : null,
        rawInicioEvent: inicio,
        rawFinEvent: matchedFinal ? matchedFinal.event : null
      });
    });

    // Si hay finales que quedaron sin emparejar (caso raro seg√∫n tu confirmaci√≥n), los ignoramos
    // Construir funci√≥n para asignar un evento a un d√≠a, buscando dentro de 'dias'
    function findDiaForTimestamp(ts){
      const t = new Date(ts);
      for(const d of dias){
        const start = new Date(d.inicio);
        const end = d.fin ? new Date(d.fin) : null;
        if(end){
          if(t >= start && t <= end) return d.dia;
        } else {
          // d√≠a en curso: t >= start
          if(t >= start) return d.dia;
        }
      }
      return null; // sin d√≠a asignado
    }

    // Filtrar solo eventos relacionados con cron√≥metros (o mantener todos pero marcaremos)
    const eventosTimers = eventosArr.filter(e =>
      e.tipo.startsWith("timer_") || e.tipo === "timer_creado" || e.tipo === "timer_editado" || e.tipo === "timer_borrado"
    );

    // Si quieres incluir tambi√©n otros tipos (ej dia_iniciado/dia_finalizado) en la tabla, agrega:
    // const eventosParaTabla = eventosArr; // pero abajo uso eventosTimers

    // Para mostrar en la tabla usaremos eventosArr que contenga tanto timer events como (opcional) dia events.
    const eventosParaTabla = eventosArr; // incluir todo, luego filtramos visualmente

    // Preparamos filas
    const filas = eventosParaTabla.map(ev => {
      // Determinar d√≠a
      const dia = findDiaForTimestamp(ev.timestamp);

      // Intentar obtener timerId y metadata
      const timerId = ev.timerId || (ev.timerId === undefined ? null : ev.timerId);
      const meta = timerId && timersMeta[timerId] ? timersMeta[timerId] : null;

      // Marca/elapsed: distintos nombres en dataExtra: elapsed, elapsedAntes, prevElapsed
      let elapsedSec = null;
      if(ev.elapsed !== undefined && ev.elapsed !== null) elapsedSec = ev.elapsed;
      else if(ev.elapsedAntes !== undefined && ev.elapsedAntes !== null) elapsedSec = ev.elapsedAntes;
      else if(ev.prevElapsed !== undefined && ev.prevElapsed !== null) elapsedSec = ev.prevElapsed;

      // objetivo (en minutos)
      const objetivo = meta ? meta.target : (ev.target || null);

      // nombre cron√≥metro: preferir ev.name (algunos eventos incluyen name), sino meta.name, sino timerId
      const nombre = ev.name || (meta ? meta.name : (timerId || ""));

      return {
        id: ev.id || `${ev.tipo}-${ev.timestamp}`,
        dia,
        tipo: ev.tipo,
        nombre,
        marca: elapsedSec,
        marcaStr: formatTimeFromSeconds(elapsedSec),
        timestamp: ev.timestamp,
        objetivo,
        creado: meta ? meta.createdAt : (ev.createdAt || ""),
        raw: ev
      };
    });

    // ordenar filas por timestamp asc
    filas.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));


/* --- SNIPPET: construir SESSIONS y exponer window.registroProcesado --- */
/* Pegar justo despu√©s de construir `eventosArr`, `dias`, `timersMeta`, `filas` */

(function createAndExposeRegistroProcesado(){
  // Construir sesiones (pares inicio -> cierre) a partir de eventosArr
  const openMap = {}; // timerId -> { startEv }
  const sessions = [];

  function closeOpenSession(timerId, endEv, closingType){
    const o = openMap[timerId];
    if(!o) return;
    const startEv = o.startEv;
    const startTs = startEv.timestamp;
    const endTs = endEv.timestamp || new Date().toISOString();
    // prefer elapsed fields if present
    const startElapsed = startEv.elapsedAntes !== undefined ? startEv.elapsedAntes : (startEv.elapsed || null);
    const endElapsed = endEv.elapsed !== undefined ? endEv.elapsed : (endEv.elapsedAntes !== undefined ? endEv.elapsedAntes : null);
    let durationSec;
    durationSec = Math.max(0, Math.floor((new Date(endTs) - new Date(startTs)) / 1000));


    // determine dia based on 'dias' intervals
    let diaNum = null;
    for(const d of dias){
      const s = new Date(d.inicio);
      const e = d.fin ? new Date(d.fin) : null;
      const st = new Date(startTs);
      if(e){
        if(st >= s && st <= e){ diaNum = d.dia; break; }
      } else {
        if(st >= s){ diaNum = d.dia; break; }
      }
    }
    const dateKey = (startTs) ? new Date(startTs).toISOString().slice(0,10) : null;

    sessions.push({
      timerId: timerId || null,
      name: (startEv.name || (timersMeta && timersMeta[timerId] && timersMeta[timerId].name) || null),
      startTs,
      endTs,
      startElapsed: startElapsed !== undefined ? startElapsed : null,
      endElapsed: endElapsed !== undefined ? endElapsed : null,
      durationSec,
      dia: diaNum,
      dateKey,
      objetivoMin: (timersMeta && timersMeta[timerId] && timersMeta[timerId].target) ? Number(timersMeta[timerId].target) : (startEv && startEv.target ? Number(startEv.target) : null),
      closingType: closingType || (endEv && endEv.tipo) || null
    });

    delete openMap[timerId];
  }

  // recorrer eventos ordenados asc
  eventosArr.forEach(ev => {
    const tipo = ev.tipo;
    const tid = ev.timerId || null;
    if(tipo === "timer_iniciado" && tid){
      // abrir
      openMap[tid] = { startEv: ev };
    } else if(tid && (tipo === "timer_pausado" || tipo === "timer_reseteado" || tipo === "timer_completado" || tipo === "timer_borrado")){
      closeOpenSession(tid, ev, tipo);
    } else if(tipo === "timer_borrado" && !tid){
      // evento borrado sin timerId: ignorar
    }
    // timer_creado / timer_editado no abren ni cierran sesiones
  });

  // cerrar sesiones abiertas usando day.fin si existe o now
  const nowIso = new Date().toISOString();
  Object.keys(openMap).forEach(timerId => {
    // intentar cerrar en el fin del d√≠a si existe el d√≠a correspondiente
    const openObj = openMap[timerId];
    const startTs = openObj.startEv.timestamp;
    // buscar dia que corresponda al start
    let closed = false;
    for(const d of dias){
      const s = new Date(d.inicio);
      const e = d.fin ? new Date(d.fin) : null;
      const st = new Date(startTs);
      if(e && st >= s && st <= e){
        // cerrar at d.fin
        const fakeEndEv = { timestamp: d.fin, tipo: "auto_cierre_por_day_end" };
        closeOpenSession(timerId, fakeEndEv, "auto_cierre_por_day_end");
        closed = true;
        break;
      }
    }
    if(!closed){
      // cerrar at now
      const fakeEndEv = { timestamp: nowIso, tipo: "auto_cierre_por_now" };
      closeOpenSession(timerId, fakeEndEv, "auto_cierre_por_now");
    }
  });

  // timersMeta ya la tienes (construida antes)
  window.registroProcesado = {
    dias: dias.map(d => ({
      dia: d.dia,
      inicio: d.inicio,
      fin: d.fin || null,
      dateKeys: d.rawInicio && d.rawInicio.timestamp ? [ (new Date(d.rawInicio.timestamp)).toISOString().slice(0,10) ] : (d.dateKeys || [])
    })),
    sessions: sessions,
    timersMeta: timersMeta || {}
  };

  // notificar a quien escuche
  window.dispatchEvent(new CustomEvent('registroProcesadoReady', { detail: window.registroProcesado }));
})();


    
    // RENDER TABLA
    const tbody = document.getElementById("registroBody");
    tbody.innerHTML = "";

    filas.forEach(f => {
      const tr = document.createElement("tr");
      if(f.dia === null) tr.classList.add("no-day");

      tr.innerHTML = `
        <td>${f.dia === null ? "<i>sin d√≠a asignado</i>" : f.dia}</td>
        <td>${escapeHtml(f.nombre || "")}</td>
        <td>${escapeHtml(f.tipo)}</td>
        <td>${f.marcaStr || ""}</td>
        <td>${formatLocal(f.timestamp)}</td>
        <td>${f.objetivo === null || f.objetivo === undefined ? "" : f.objetivo}</td>
        <td>${f.creado ? formatLocal(f.creado) : ""}</td>
      `;
      tbody.appendChild(tr);
    });

    // Si no hay d√≠as detectados, mostrar nota
    if(dias.length === 0){
      // opci√≥n: mostrar alerta o mensaje en la UI (aqu√≠ agregamos una fila)
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="7" class="small">No se detectaron pares dia_iniciado / dia_finalizado. Si existe un d√≠a en curso, aparecer√° como 'en curso' (fin vac√≠o).</td>`;
      tbody.prepend(tr);
    }

  }); // onValue
} // renderRegistroEventos

// utilidad m√≠nima para escapar HTML en nombres/strings
function escapeHtml(unsafe) {
  if(!unsafe && unsafe !== 0) return "";
  return String(unsafe)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'", "&#039;");
}

/* ===========================
   ====== FIN registro UI =====
   =========================== */

</script>

 
<!-- Conexi√≥n al archivo externo de estad√≠sticas -->
<script type="module" src="estadisticas.js"></script>

</body>
</html>


















































