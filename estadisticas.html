<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Estad√≠sticas (crudo desde historial)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body{font-family:Segoe UI, sans-serif; padding:18px; background:#f5f5f7; color:#111}
  .card{background:#fff;border-radius:10px;padding:14px;margin-bottom:14px;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
  h1{margin:0 0 10px}
  #filters{display:flex;gap:10px;flex-wrap:wrap}
  select,input{padding:6px;border-radius:6px;border:1px solid #ddd}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{padding:8px;border-bottom:1px solid #eee;font-size:13px}
  .small{font-size:12px;color:#666}
</style>
</head>
<body>
  <h1>üìä Estad√≠sticas ‚Äî Desde historialEventos</h1>

  <div class="card" id="infoCard">
    <div class="small">Este panel lee <b>directamente</b> el historial de eventos (usuarios/{uid}/historialEventos) y los objetivos desde <b>localStorage</b> (timersMetaLocal). Aseg√∫rate de abrir esta p√°gina desde la misma m√°quina donde usas el index o que index haya guardado <code>timersMetaLocal</code>.</div>
  </div>

  <div class="card">
    <h3>Filtros</h3>
    <div id="filters">
      <select id="filterDia"><option value="">Todos los d√≠as</option></select>
      <select id="filterFecha"><option value="">Todas las fechas</option></select>
      <input id="searchName" placeholder="Buscar actividad (nombre)" />
      <button id="refreshBtn">üîÅ Refrescar</button>
      <div class="small" id="status" style="margin-left:auto"></div>
    </div>
  </div>

  <div class="card">
    <h3>Resumen</h3>
    <div id="resumen"></div>
  </div>

  <div class="card">
    <h3>Tiempo por actividad</h3>
    <canvas id="chartActividades" height="120"></canvas>
  </div>

  <div class="card">
    <h3>Tiempo por d√≠a</h3>
    <canvas id="chartDias" height="120"></canvas>
  </div>

  <div class="card">
    <h3>Sesiones (reconstruidas desde historial)</h3>
    <table>
      <thead><tr>
        <th>Actividad</th><th>D√≠a</th><th>Fecha</th><th>Inicio</th><th>Fin</th><th>Duraci√≥n</th><th>Objetivo (min)</th><th>Cumplido</th>
      </tr></thead>
      <tbody id="tablaSesiones"></tbody>
    </table>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getDatabase, ref, onValue, get } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

/* ========== CONFIG FIREBASE ========== */
const firebaseConfig = {
  apiKey: "AIzaSyCby9oxzPzBDllkzuW21ZoGNJh67UgYZ8E",
  authDomain: "notion-timers-2a3bb.firebaseapp.com",
  databaseURL: "https://notion-timers-2a3bb-default-rtdb.firebaseio.com",
  projectId: "notion-timers-2a3bb",
  storageBucket: "notion-timers-2a3bb.firebasestorage.app",
  messagingSenderId: "78500747038",
  appId: "1:78500747038:web:2b5fdec3731a203c7f1b0f"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ========== UTIL HELPERS ========== */
const $ = id => document.getElementById(id);

function parseMarcaString(m){
  // acepta "HH:MM:SS" o "0:01:03"
  if(!m && m!==0) return null;
  if(typeof m === "number") return Number(m);
  const s = String(m).trim();
  if(!s) return null;
  const parts = s.split(':').map(p => Number(p));
  if(parts.length === 3){
    return parts[0]*3600 + parts[1]*60 + parts[2];
  } else if(parts.length === 2){
    return parts[0]*60 + parts[1];
  } else {
    const n = Number(s);
    return isNaN(n) ? null : n;
  }
}

// preferElapsed: intenta extraer elapsed de varios nombres posibles
function extractElapsedFromEvent(ev){
  if(ev == null) return null;
  const candidates = ['endElapsed','startElapsed','elapsed','elapsedAntes','marcaElapsed','marcaSeconds','marcaSec'];
  for(const k of candidates){
    if(ev[k] !== undefined && ev[k] !== null && ev[k] !== "") return Number(ev[k]);
  }
  // si hay campo 'marca' en formato HH:MM:SS
  if(ev.marca !== undefined && ev.marca !== null){
    const p = parseMarcaString(ev.marca);
    if(p !== null) return Number(p);
  }
  // si hay campo 'marcaStr' o 'marcaStr' etc
  if(ev.marcaStr !== undefined && ev.marcaStr !== null){
    const p = parseMarcaString(ev.marcaStr);
    if(p !== null) return Number(p);
  }
  return null;
}

// diff marcas preferente: end - start (si ambos disponibles)
function durationFromPair(startEv, endEv){
  // primer intento: buscar campos num√©ricos absolutos (elapsed acumulado)
  // muchos eventos guardaron elapsedAntes/elapsed (valor acumulado) => diff
  const startCandidates = ['elapsedAntes','elapsed','startElapsed'];
  const endCandidates = ['elapsed','endElapsed','elapsedAntes'];
  let startVal = null, endVal = null;

  for(const k of startCandidates) if(startEv[k] !== undefined && startEv[k] !== null) { startVal = Number(startEv[k]); break; }
  if(startVal === null) {
    // intentar marca string en startEv
    startVal = extractElapsedFromEvent(startEv);
  }
  for(const k of endCandidates) if(endEv[k] !== undefined && endEv[k] !== null) { endVal = Number(endEv[k]); break; }
  if(endVal === null) {
    endVal = extractElapsedFromEvent(endEv);
  }

  if(startVal !== null && endVal !== null && !isNaN(startVal) && !isNaN(endVal) && endVal >= startVal){
    return Math.max(0, Math.floor(endVal - startVal));
  }

  // fallback: si existen marca strings HH:MM:SS en ambos
  const s1 = startEv.marca || startEv.marcaStr || startEv.marca_str || null;
  const s2 = endEv.marca || endEv.marcaStr || endEv.marca_str || null;
  if(s1 && s2){
    const ps1 = parseMarcaString(s1), ps2 = parseMarcaString(s2);
    if(ps1 !== null && ps2 !== null && ps2 >= ps1) return Math.max(0, ps2 - ps1);
  }

  // ultimate fallback: diferencia de timestamps (segundos)
  try {
    const st = new Date(startEv.timestamp).getTime();
    const en = new Date(endEv.timestamp).getTime();
    if(!isNaN(st) && !isNaN(en) && en >= st) return Math.max(0, Math.floor((en - st)/1000));
  } catch(e){}
  return 0;
}

/* ========== Obtener UID de la URL (opcional) o detectar autom√°ticamente ========== */
const params = new URLSearchParams(window.location.search);
const uid = params.get("uid");
if(!uid){
  // intentar obtener UID de localStorage si index la guard√≥
  try {
    const uls = localStorage.getItem("currentUid");
    if(uls) {
      // si index guarda currentUid
      console.log("UID from localStorage", uls);
    }
  } catch(e){}
}

/* ========== Read local timers meta (guardado por index) ========== */
function readTimersMetaLocal(){
  try {
    const raw = localStorage.getItem("timersMetaLocal");
    if(!raw) return {};
    return JSON.parse(raw);
  } catch(e){
    console.warn("timersMetaLocal parse error", e);
    return {};
  }
}

/* ========== Reconstrucci√≥n: leer historialEventos desde Firebase para el uid dado ========== */
function pathForUid(u){
  if(!u) throw new Error("UID no provisto. Abre esta p√°gina con ?uid=... o usa index que guarde timersMetaLocal.");
  return `usuarios/${u}/historialEventos`;
}

const refreshBtn = $('refreshBtn');
refreshBtn.onclick = () => {
  startListening();
};

const status = $('status');
let listenerUnsub = null;

async function startListening(){
  status.textContent = "Cargando historial...";
  if(!uid){
    status.textContent = "No se recibi√≥ uid en la URL. Aseg√∫rate de abrir desde index con ?uid=UID o guarda timersMetaLocal en localStorage.";
    console.warn("UID faltante. Alternativamente, aseg√∫rate que localStorage.timersMetaLocal exista.");
    // intentamos igualmente leer localStorage y terminar con mensaje
    rebuildFromLocalOnly();
    return;
  }

  const eventosRef = ref(db, pathForUid(uid));
  if(listenerUnsub) listenerUnsub(); // no existe en modular onValue no retorna func; but onValue returns unsubscribe function ‚Äî we stored it earlier
  // onValue returns unsubscribe function in modular v11
  listenerUnsub = onValue(eventosRef, snap => {
    const raw = snap.val() || {};
    const eventosArr = Object.entries(raw).map(([k,v]) => ({ id:k, ...v }));
    eventosArr.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
    status.textContent = `Eventos le√≠dos: ${eventosArr.length}`;
    processRawEvents(eventosArr);
  }, err => {
    console.error("Error leyendo historial:", err);
    status.textContent = "Error leyendo historial. Mira la consola.";
  });
}

function rebuildFromLocalOnly(){
  const timersMetaLocal = readTimersMetaLocal();
  // no hay historial: avisar
  status.textContent = "UID no provisto; usando s√≥lo timersMetaLocal (no habr√° sesiones).";
  // mostramos objetivos por timersMetaLocal para inspecci√≥n
  console.log("timersMetaLocal:", timersMetaLocal);
}

/* ========== processRawEvents: construir dias y sesiones EXACTAMENTE igual a la tabla ========== */
function processRawEvents(eventosArr){
  // Primero: construir timersMetaFromEvents (timer_creado)
  const timersMetaFromEvents = {};
  eventosArr.forEach(ev => {
    if(ev.tipo === "timer_creado" && ev.timerId){
      timersMetaFromEvents[ev.timerId] = {
        name: ev.name || ev.timerId,
        targetMin: ev.target !== undefined && ev.target !== null ? Number(ev.target) : null,
        createdAt: ev.timestamp || ev.createdAt || null
      };
    }
  });

  // construir dias (pares dia_iniciado/dia_finalizado) - la misma l√≥gica que en index
  const inicios = eventosArr.filter(e => e.tipo === "dia_iniciado");
  const finales = eventosArr.filter(e => e.tipo === "dia_finalizado");
  const dias = [];
  const usedFinal = new Set();
  inicios.forEach((ini) => {
    const iniTs = new Date(ini.timestamp);
    let matched = null;
    for(let j=0;j<finales.length;j++){
      if(usedFinal.has(j)) continue;
      const f = finales[j];
      if(new Date(f.timestamp) >= iniTs){
        matched = f; usedFinal.add(j); break;
      }
    }
    dias.push({ inicio: ini.timestamp, fin: matched ? matched.timestamp : null, rawInicio: ini, rawFin: matched || null });
  });

  // construir sesiones: emparejar timer_iniciado -> (pausa|completado|reseteado|borrado)
  const openMap = {}; // timerId -> startEv
  const sessions = [];

  eventosArr.forEach(ev => {
    const tipo = ev.tipo;
    const tid = ev.timerId || null;

    if(tipo === "timer_iniciado" && tid){
      // registrar inicio (guardar el evento completo)
      openMap[tid] = ev;
    } else if(tid && ["timer_pausado","timer_reseteado","timer_completado","timer_borrado"].includes(tipo)){
      // cerrar sesi√≥n si hay un inicio abierto
      const startEv = openMap[tid];
      if(startEv){
        const duration = durationFromPair(startEv, ev);
        // determinar dia bas√°ndonos en startEv.timestamp y dias list
        let diaNum = null;
        for(let i=0;i<dias.length;i++){
          const s = new Date(dias[i].inicio);
          const e = dias[i].fin ? new Date(dias[i].fin) : null;
          const st = new Date(startEv.timestamp);
          if(e){
            if(st >= s && st <= e){ diaNum = i+1; break; }
          } else {
            if(st >= s){ diaNum = i+1; break; }
          }
        }
        const dateKey = startEv.timestamp ? new Date(startEv.timestamp).toISOString().slice(0,10) : null;

        sessions.push({
          timerId: tid,
          name: startEv.name || (timersMetaFromEvents[tid] && timersMetaFromEvents[tid].name) || null,
          startTs: startEv.timestamp,
          endTs: ev.timestamp,
          startElapsed: extractElapsedFromEvent(startEv),
          endElapsed: extractElapsedFromEvent(ev),
          durationSec: duration,
          dia: diaNum,
          dateKey,
          closingType: ev.tipo || null
        });

        delete openMap[tid];
      } else {
        // no hay inicio: quiz√° el evento de inicio no est√° en el rango; ignoramos o creamos start ficticio
        // intentamos crear una sesi√≥n corta usando only ev (no ideal)
        const duration = extractElapsedFromEvent(ev) || 0;
        sessions.push({
          timerId: tid,
          name: ev.name || (timersMetaFromEvents[tid] && timersMetaFromEvents[tid].name) || null,
          startTs: ev.timestamp,
          endTs: ev.timestamp,
          startElapsed: null,
          endElapsed: extractElapsedFromEvent(ev),
          durationSec: duration,
          dia: null,
          dateKey: ev.timestamp ? new Date(ev.timestamp).toISOString().slice(0,10) : null,
          closingType: ev.tipo || null
        });
      }
    }
    // otros tipos no abren ni cierran
  });

  // cerrar sesiones que quedan abiertas con el fin del d√≠a o now
  const nowIso = new Date().toISOString();
  Object.keys(openMap).forEach(tid => {
    const startEv = openMap[tid];
    // intentar cerrar al fin del d√≠a correspondiente (si existe)
    let closed = false;
    for(const d of dias){
      const s = new Date(d.inicio);
      const e = d.fin ? new Date(d.fin) : null;
      const st = new Date(startEv.timestamp);
      if(e && st >= s && st <= e){
        // crear evento fake al fin del d√≠a
        const fakeEnd = { timestamp: d.fin, tipo: "auto_cierre_por_day_end" };
        const duration = durationFromPair(startEv, fakeEnd);
        sessions.push({
          timerId: tid,
          name: startEv.name || (timersMetaFromEvents[tid] && timersMetaFromEvents[tid].name) || null,
          startTs: startEv.timestamp,
          endTs: d.fin,
          startElapsed: extractElapsedFromEvent(startEv),
          endElapsed: null,
          durationSec: duration,
          dia: null,
          dateKey: startEv.timestamp ? new Date(startEv.timestamp).toISOString().slice(0,10) : null,
          closingType: "auto_cierre_por_day_end"
        });
        closed = true;
        break;
      }
    }
    if(!closed){
      const fakeEnd = { timestamp: nowIso, tipo: "auto_cierre_por_now" };
      const duration = durationFromPair(startEv, fakeEnd);
      sessions.push({
        timerId: tid,
        name: startEv.name || (timersMetaFromEvents[tid] && timersMetaFromEvents[tid].name) || null,
        startTs: startEv.timestamp,
        endTs: nowIso,
        startElapsed: extractElapsedFromEvent(startEv),
        endElapsed: null,
        durationSec: duration,
        dia: null,
        dateKey: startEv.timestamp ? new Date(startEv.timestamp).toISOString().slice(0,10) : null,
        closingType: "auto_cierre_por_now"
      });
    }
  });

  // ahora tenemos sesiones y dias
  // obtener objetivos de dos fuentes: localStorage (preferente) y timersMetaFromEvents (fallback)
  const timersMetaLocal = readTimersMetaLocal();
  // build a map: by timerId (tid) -> { name, targetMin }
  const metaFinal = {};
  // prefer local storage (index)
  Object.keys(timersMetaLocal || {}).forEach(k => { metaFinal[k] = timersMetaLocal[k]; });
  // fallback a events-created metadata
  Object.keys(timersMetaFromEvents).forEach(k => {
    if(!metaFinal[k]) metaFinal[k] = timersMetaFromEvents[k];
  });

  // ahora calculos agregados: acumulados por timer y por dia
  const acumuladoPorTimer = {};
  const sesionesOrdenadas = sessions.sort((a,b)=> new Date(a.startTs) - new Date(b.startTs));
  sesionesOrdenadas.forEach(s => {
    acumuladoPorTimer[s.timerId] = (acumuladoPorTimer[s.timerId] || 0) + (Number(s.durationSec) || 0);
  });

  // calcular rachas: por dia, objetivo = suma de objetivos de timers participantes en ese dia (tomando metaFinal)
  const trabajadoPorDia = {};
  const timersPorDia = {};
  sesionesOrdenadas.forEach(s => {
    if(s.dia == null) return;
    trabajadoPorDia[s.dia] = (trabajadoPorDia[s.dia] || 0) + Number(s.durationSec || 0);
    timersPorDia[s.dia] = timersPorDia[s.dia] || new Set();
    if(s.timerId) timersPorDia[s.dia].add(s.timerId);
  });
  const objetivosPorDia = {};
  Object.keys(timersPorDia).forEach(d => {
    let sum = 0;
    timersPorDia[d].forEach(tid => {
      const m = metaFinal[tid];
      const tmin = m ? Number(m.targetMin || m.target || 0) : 0;
      sum += tmin * 60;
    });
    objetivosPorDia[d] = sum;
  });
  let maxRacha = 0, rachaActual = 0, prev = null;
  const diasOrdenados = Object.keys(trabajadoPorDia).map(n=>Number(n)).sort((a,b)=>a-b);
  diasOrdenados.forEach(d => {
    const cumplido = (objetivosPorDia[d] && objetivosPorDia[d] > 0) ? (trabajadoPorDia[d] >= objetivosPorDia[d]) : false;
    if(prev === null || d === prev + 1){
      rachaActual = cumplido ? rachaActual + 1 : 0;
    } else {
      rachaActual = cumplido ? 1 : 0;
    }
    maxRacha = Math.max(maxRacha, rachaActual);
    prev = d;
  });

  // PREPARAR datos para render
  window._estad_backend = {
    eventosArr,
    dias,
    sessions: sesionesOrdenadas,
    metaFinal,
    acumuladoPorTimer,
    objetivosPorDia,
    maxRacha
  };

  console.log("RECONSTRUCCION completa. window._estad_backend:", window._estad_backend);

  renderAll(sesionesOrdenadas, dias, metaFinal, acumuladoPorTimer, objetivosPorDia, maxRacha);
}

/* ========== RENDER UI: filtros, tabla, graficas ========== */
function renderAll(sessions, dias, metaFinal, acumuladoPorTimer, objetivosPorDia, maxRacha){
  // filtros
  const fDia = $('filterDia'); fDia.innerHTML = `<option value="">Todos los d√≠as</option>`;
  dias.forEach((d,i)=> fDia.innerHTML += `<option value="${i+1}">D√≠a ${i+1}</option>`);

  const fechaSet = new Set(sessions.map(s=>s.dateKey).filter(x=>x));
  const fFecha = $('filterFecha'); fFecha.innerHTML = `<option value="">Todas las fechas</option>`;
  Array.from(fechaSet).sort().forEach(fn => fFecha.innerHTML += `<option value="${fn}">${fn}</option>`);

  $('searchName').oninput = renderTodo;
  fDia.onchange = renderTodo; fFecha.onchange = renderTodo;

  // render inicial
  renderTodo();

  function filtrar(){
    const d = fDia.value; const f = fFecha.value; const q = $('searchName').value.trim().toLowerCase();
    return sessions.filter(s => {
      if(d && String(s.dia) !== String(d)) return false;
      if(f && s.dateKey !== f) return false;
      if(q && (!s.name || !s.name.toLowerCase().includes(q))) return false;
      return true;
    });
  }

  function formatSec(s){
    const h = Math.floor(s/3600);
    const m = Math.floor((s%3600)/60);
    const ss = s%60;
    return `${h}h ${m}m ${ss}s`;
  }

  function renderTablaLocal(){
    const ss = filtrar();
    const tbody = $('tablaSesiones'); tbody.innerHTML = "";
    const acumuladoLocal = {};
    ss.forEach(s => {
      const tid = s.timerId;
      acumuladoLocal[tid] = (acumuladoLocal[tid] || 0) + Number(s.durationSec || 0);
      const meta = metaFinal[tid] || {};
      const objetivoMin = Number(meta.targetMin || meta.target || 0);
      const objetivoSec = objetivoMin * 60;
      const cumplido = objetivoSec > 0 ? (acumuladoLocal[tid] >= objetivoSec ? "‚úî" : "‚úñ") : "‚Äî";

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${s.name || (meta && meta.name) || s.timerId}</td>
        <td>${s.dia || ''}</td>
        <td>${s.dateKey || ''}</td>
        <td>${s.startTs ? new Date(s.startTs).toLocaleString() : ''}</td>
        <td>${s.endTs ? new Date(s.endTs).toLocaleString() : ''}</td>
        <td>${formatSec(Number(s.durationSec||0))}</td>
        <td>${objetivoMin}</td>
        <td>${cumplido}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  // graficas
  let chartA = null, chartD = null;
  function renderCharts(){
    const ss = filtrar();
    const aggAct = {};
    const aggDia = {};
    ss.forEach(s => {
      const name = s.name || (metaFinal[s.timerId] && metaFinal[s.timerId].name) || s.timerId;
      aggAct[name] = (aggAct[name] || 0) + Number(s.durationSec || 0);
      aggDia[s.dia || "sin"] = (aggDia[s.dia || "sin"] || 0) + Number(s.durationSec || 0);
    });

    const labelsAct = Object.keys(aggAct);
    const dataAct = Object.values(aggAct);

    if(chartA) chartA.destroy();
    chartA = new Chart($('chartActividades'), { type:'bar', data:{ labels:labelsAct, datasets:[{ label:'Segundos', data:dataAct }]} });

    const labelsDia = Object.keys(aggDia).map(d => d === 'sin' ? 'sin d√≠a' : 'D√≠a ' + d);
    const dataDia = Object.values(aggDia);
    if(chartD) chartD.destroy();
    chartD = new Chart($('chartDias'), { type:'line', data:{ labels:labelsDia, datasets:[{ label:'Segundos', data:dataDia, tension:0.25 }] } });
  }

  function renderResumenLocal(){
    const ss = filtrar();
    const total = ss.reduce((a,b)=>a+Number(b.durationSec||0),0);
    const diasUnicos = new Set(ss.map(s=>s.dia).filter(x=>x));
    const fechasUnicas = new Set(ss.map(s=>s.dateKey).filter(x=>x));
    $('resumen').innerHTML = `<p><b>Tiempo total:</b> ${formatSec(total)}</p>
      <p><b>D√≠as trabajados:</b> ${diasUnicos.size}</p>
      <p><b>Fechas √∫nicas:</b> ${fechasUnicas.size}</p>
      <p><b>Racha m√°xima (cumplimiento por d√≠a):</b> ${window._estad_backend.maxRacha}</p>`;
  }

  function renderTodo(){
    renderTablaLocal();
    renderCharts();
    renderResumenLocal();
  }
}

/* ========== Inicial: arrancar escucha ========== */
startListening();

</script>
</body>
</html>









